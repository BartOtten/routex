searchData={"items":[{"type":"module","title":"Routex.Test.Fixtures","doc":"","ref":"Routex.Test.Fixtures.html"},{"type":"function","title":"Routex.Test.Fixtures.branches/0","doc":"","ref":"Routex.Test.Fixtures.html#branches/0"},{"type":"function","title":"Routex.Test.Fixtures.branches_flat/0","doc":"","ref":"Routex.Test.Fixtures.html#branches_flat/0"},{"type":"function","title":"Routex.Test.Fixtures.branches_precomputed/0","doc":"","ref":"Routex.Test.Fixtures.html#branches_precomputed/0"},{"type":"function","title":"Routex.Test.Fixtures.branches_with_map_attrs/0","doc":"","ref":"Routex.Test.Fixtures.html#branches_with_map_attrs/0"},{"type":"module","title":"Routex.Test.Fixtures.Assigns","doc":"","ref":"Routex.Test.Fixtures.Assigns.html"},{"type":"module","title":"Routex.Test.Support.Gettext","doc":"","ref":"Routex.Test.Support.Gettext.html"},{"type":"function","title":"Routex.Test.Support.Gettext.handle_missing_bindings/2","doc":"Callback implementation for  Gettext.Backend.handle_missing_bindings/2 .","ref":"Routex.Test.Support.Gettext.html#handle_missing_bindings/2"},{"type":"function","title":"Routex.Test.Support.Gettext.handle_missing_plural_translation/7","doc":"Callback implementation for  Gettext.Backend.handle_missing_plural_translation/7 .","ref":"Routex.Test.Support.Gettext.html#handle_missing_plural_translation/7"},{"type":"function","title":"Routex.Test.Support.Gettext.handle_missing_translation/5","doc":"Callback implementation for  Gettext.Backend.handle_missing_translation/5 .","ref":"Routex.Test.Support.Gettext.html#handle_missing_translation/5"},{"type":"module","title":"Routex","doc":"Routex enhances the Phoenix Router by providing an extension-driven framework\n  for advanced routing capabilities. It simplifies route manipulation, offering\n  features such as internationalization (i18n), localization (l10n), translated\n  (multilingual) URLs, and alternative route generation.\n\n---\n\n  **Features**\n\n  - **Internationalization (i18n) and Localization (l10n):**  \n    Seamlessly integrate multilingual support into your Phoenix applications,\n    allowing routes to adapt based on locale settings.\n\n  - **Translated URLs:**  \n    Generate and manage URLs in multiple languages, enhancing user experience\n    for global audiences.\n\n  - **Alternative Route Generation:**  \n    Create multiple route variations effortlessly, catering to diverse routing\n    requirements.\n\n  - **Extensible Architecture:**  \n    Leverage a modern, extensible architecture to build custom solutions that\n    work harmoniously with existing extensions.\n\n---\n\n  **Documentation and Resources**\n\n  For comprehensive information and guidance, refer to the following resources\n  relative to the project's root directory:\n\n  - [`README.md`](README.md):\n    Overview of the project, including installation instructions and basic\n    usage.\n\n  - [`USAGE.md`](USAGE.md):\n    Detailed guidance on implementing and utilizing Routex's functionalities.\n\n  - [`CONTRIBUTING.md`](CONTRIBUTING.md):\n    Guidelines for contributing to the project, including coding standards and\n    submission processes.\n\n  - [`docs/COMPARISON.md`](docs/COMPARISON.md):\n    Comparison with similar tools or libraries, highlighting unique features\n    and advantages.\n\n  - [`docs/EXTENSION_DEVELOPMENT.md`](docs/EXTENSION_DEVELOPMENT.md):\n    Instructions on developing extensions to enhance or customize Routex's\n    capabilities.\n\n  - [`docs/EXTENSIONS.md`](docs/EXTENSIONS.md):\n    Summaries of available extensions, detailing their functionalities and\n    integration methods.\n\n  - [`docs/ROUTEX_AND_PHOENIX_ROUTER.md`](docs/ROUTEX_AND_PHOENIX_ROUTER.md):\n    Explanation of how Routex integrates with the Phoenix Router, providing a\n    blueprint for understanding their collaboration.","ref":"Routex.html"},{"type":"module","title":"Routex.Attrs","doc":"Provides an interface to access and update Routex attributes\nin routes, sockets, or connections (hereinafter `containers`).\n\nExtensions can make use of `Routex.Attrs` values provided by Routex itself,\nRoutex backends, and other extensions. As these values are attributes to a route,\none extension can use values set by another.\n\nOther extensions set `Routex.Attrs` (see each extension’s documentation for the\nlist of attributes they set). To define custom attributes for routes, see\n`Routex.Extension.Alternatives`.\n\n* To ensure predictable availability, Routex uses a flat structure.\n* Extension developers are encouraged to embed as much contextual information as possible.\n* Extensions should add any fallback/default they might use to the attributes.","ref":"Routex.Attrs.html"},{"type":"type","title":"Routex.Attrs.attrs_fun/0","doc":"","ref":"Routex.Attrs.html#t:attrs_fun/0"},{"type":"type","title":"Routex.Attrs.container/0","doc":"","ref":"Routex.Attrs.html#t:container/0"},{"type":"type","title":"Routex.Attrs.key/0","doc":"","ref":"Routex.Attrs.html#t:key/0"},{"type":"type","title":"Routex.Attrs.t/0","doc":"","ref":"Routex.Attrs.html#t:t/0"},{"type":"type","title":"Routex.Attrs.update_fun/0","doc":"","ref":"Routex.Attrs.html#t:update_fun/0"},{"type":"type","title":"Routex.Attrs.value/0","doc":"","ref":"Routex.Attrs.html#t:value/0"},{"type":"function","title":"Routex.Attrs.cleanup/1","doc":"Removes non-private fields from attributes.\n\nWhen given a plain map, it filters the map to include only keys starting with `\"__\"`.\nWhen given a container (a map with a `:private` key), it filters the `:routex` attributes\nin the private map.","ref":"Routex.Attrs.html#cleanup/1"},{"type":"function","title":"Routex.Attrs.get/3","doc":"Retrieves the value for `key` from the container's attributes, or returns `default`.\n\nWhen no key is provided, returns the entire attributes map.","ref":"Routex.Attrs.html#get/3"},{"type":"function","title":"Routex.Attrs.get!/3","doc":"Retrieves the value for `key` from the container's attributes.\n\nRaises an error (with an optional custom message) if the key is not found.","ref":"Routex.Attrs.html#get!/3"},{"type":"function","title":"Routex.Attrs.merge/2","doc":"Merges the given value into the container's attributes.\n\nThe value can be either a list of key-value pairs or a map.","ref":"Routex.Attrs.html#merge/2"},{"type":"function","title":"Routex.Attrs.merge/3","doc":"","ref":"Routex.Attrs.html#merge/3"},{"type":"function","title":"Routex.Attrs.private?/1","doc":"Returns true if the given key or attribute tuple represents a private attribute.\n\nA private attribute is one whose name starts with `\"__\"`.","ref":"Routex.Attrs.html#private?/1"},{"type":"function","title":"Routex.Attrs.put/2","doc":"Replaces the container's attributes with the provided map.","ref":"Routex.Attrs.html#put/2"},{"type":"function","title":"Routex.Attrs.put/3","doc":"Assigns `value` to `key` in the container's attributes.","ref":"Routex.Attrs.html#put/3"},{"type":"function","title":"Routex.Attrs.update/2","doc":"Updates the container's attributes by applying the given function.\n\nThe function receives the current attributes map and must return an enumerable,\nwhich is then converted into a new map.","ref":"Routex.Attrs.html#update/2"},{"type":"function","title":"Routex.Attrs.update/3","doc":"Updates the value assigned to `key` in the container's attributes by applying the given function.","ref":"Routex.Attrs.html#update/3"},{"type":"module","title":"Routex.Backend","doc":"> #### `use Routex.Backend`\n> When used, this module generates a Routex backend module and a configuration struct\n> by running the `configure/2` callbacks of the extensions provided in `opts`.\n>\n> See also: [Routex Extensions](EXTENSION_DEVELOPMENT.md).","ref":"Routex.Backend.html"},{"type":"type","title":"Routex.Backend.t/0","doc":"A Routex backend module","ref":"Routex.Backend.html#t:t/0"},{"type":"module","title":"Routex.Branching","doc":"Provides a function to build branched variants of macro's","ref":"Routex.Branching.html"},{"type":"function","title":"Routex.Branching.branch_macro/5","doc":"Takes a list of match patterns and creates the AST for branching variants for\nall arities of `macro` in `module` by wrapping them in a `case` statement.\n\n\n** Args **\n\n- `patterns`: the match patterns to be used as case clauses\n- `match_binding`: ast inserted as `case [match_binding] do`\n- `module`: the module name\n- `macro`: the macro name\n- `opts`: list of options\n\n\n** Options **\n- `arities`: a list of arities to transform, default: all arities\n- `as`: name of the branching variant. default: the macro name\n- `arg_post`: function to calculate the replaced argument position. default: 0\n\nThe clauses and arguments can be transformed by providing MFA's. The\ntransformers receive as arguments the `pattern`, the `banched arg` and any\nother argument provided in `a`.\n\n- `clause_transformer`: {m,f,a}. transforms a pattern; used as case clause in the macro body.\n- `arg_transformer`: {m,f,a}.  transforms a branched argument; used in the macro body.\n\n** Example **\n\nWe want to create a branching variant of the `url` macro in `Phoenix.VerifiedRoutes` module. The original\nmacro generates code that simply prints the given path argument, but we want to it to write multiple clauses and\nprefix the given argument based on the clause.\n\n    defmacro url(path, opts \\ []) do -> quote do IO.puts(path) end\n\nGiven this code:\n\n    defmodule MyMod do\n      def transform_arg(pattern, arg, extra), do: \"/\" <> extra <> \"/europe/\" <> pattern <> \"/\" <> arg end\n    end\n\n    patterns = [\"en\", \"nl\"]\n    match_binding = var!(external_var)\n    arg_pos = fn arity -> arity - 1 end)\n    arg_transformer = {MyMod, transform_arg, [\"my_extra\"]}\n    opts = [as: :url, orig: :url_original, arg_pos: arg_pos, arg_transformer: arg_transformer]\n\n    branch_macro(patterns, match_binding, OriginalModule, :url, opts)\n\nA new macro is build which outputs the AST of the original macro, wrapped in a case clause given transformed arguments.\n\n    defmacro url(path, opts \\ []) do\n\t    quote do\n\t      case external_var do\n\t  \t\t \"en\" -> Original.Module.url( \"/\" <> \"my_extra\" <> \"/europe/en/\" <> path, opts)\n\t  \t\t \"nl\" -> Original.Module.url(\"/\" <> \"my_extra\" <> \"/europe/nl/\" <> path, opts)\n\t  \t end\n       end\n     end\n\n\nFor more examples, please see the test module `Routex.BranchingTest`.","ref":"Routex.Branching.html#branch_macro/5"},{"type":"module","title":"Routex.Dev","doc":"Provides functions to aid during development","ref":"Routex.Dev.html"},{"type":"function","title":"Routex.Dev.inspect_ast/2","doc":"`Macro.escape/1` and `IO.inspect/2` the given input. Options are\npassed through to `IO.inspect`. Returns the input.","ref":"Routex.Dev.html#inspect_ast/2"},{"type":"function","title":"Routex.Dev.print_ast/2","doc":"Helper function to inspect AST as formatted code. Returns the\ninput.","ref":"Routex.Dev.html#print_ast/2"},{"type":"function","title":"Examples - Routex.Dev.print_ast/2","doc":"iex> ast = quote do: Map.put(my_map, :key, value)\n    iex> print_ast(ast)\n    Map.put(my_map, :key, value)\n    ...actual AST...","ref":"Routex.Dev.html#print_ast/2-examples"},{"type":"behaviour","title":"Routex.Extension","doc":"Specification for composable Routex extensions.\n\nAll callbacks are *optional*\n\nSee also: [Routex Extensions](EXTENSION_DEVELOPMENT.md)","ref":"Routex.Extension.html"},{"type":"callback","title":"Routex.Extension.configure/2","doc":"The `configure/2` callback is called in the first stage with the options\nprovided to `Routex` and the name of the Routex backend. It is expected to\nreturn a new list of options.","ref":"Routex.Extension.html#c:configure/2"},{"type":"callback","title":"Routex.Extension.create_helpers/3","doc":"The `create_helpers/3` callback is called in the last stage with a list of\nroutes belonging to a Routex backend, the name of the Routex backend and the\ncurrent environment. It is expected to return Elixir AST.\n\nThis can be used to create dedicated backend. As multiple backends may include\nthe extension, no catchall fallback is allowed. (see:\n`create_shared_helpers/3`).\n\n```elixir\ndef my_fun(%{arg: RoutexBackend.Default}), do: :foo\n```\n\nThe AST is included in `MyAppWeb.Router.RoutexHelpers`.","ref":"Routex.Extension.html#c:create_helpers/3"},{"type":"callback","title":"Routex.Extension.create_shared_helpers/3","doc":"The `create_shared_helpers/3` callback is called in the last stage. It differs\nfrom `create_helpers/3` as it is called only once per extension with routes\ncombined of all backends using the extension.\n\nThis can be used to create cross-backend (combined) helpers or dedicated\nbackend helpers combined with an additional catch all function head.\n\n```elixir\ndef my_fun(%{arg: RoutexBackend.Default}), do: :foo\ndef my_fun(%{arg: RoutexBackend.Other}), do: :bar\ndef my_fun(_), do: :biz\n```\n\nor\n\n```elixir\ndef my_fun(socket) do\n  ...some shared code...\n  case socket_to_backend(socket) do\n    %{arg: RoutexBackend.Default} ->  :foo\n    %{arg: RoutexBackend.Other} ->  :bar\n     _ ->  :biz\n  end\nend\n```\n\nThe AST is included in `MyAppWeb.Router.RoutexHelpers`.","ref":"Routex.Extension.html#c:create_shared_helpers/3"},{"type":"callback","title":"Routex.Extension.post_transform/3","doc":"The `post_transform/1` callback is called in the third stage with a list of\nroutes belonging to a Routex backend. It is expected to return a list of\nPhoenix.Router.Route structs almost identical to the input, only adding\n`Routex.Attrs` -for own usage- is allowed.","ref":"Routex.Extension.html#c:post_transform/3"},{"type":"callback","title":"Routex.Extension.transform/3","doc":"The `transform/3` callback is called in the second stage with a list of\nroutes belonging to a Routex backend, the name of the configuration model\nand the current environment. It is expected to return a list of\nPhoenix.Router.Route structs with flattened `Routex.Attrs`.","ref":"Routex.Extension.html#c:transform/3"},{"type":"module","title":"Routex.HelperFallbacks","doc":"Provides fallback functions when `use`'d","ref":"Routex.HelperFallbacks.html"},{"type":"module","title":"Routex.Matchable","doc":"Matchables are an essential part of Routex. They are used to match run time\nroutes with compile time routes and enable reordered route segments.\n\nThis module provides functions to create Matchables, convert them to match\npattern AST as well as function head AST, and check if the routing values\nof two Matchable records match.","ref":"Routex.Matchable.html"},{"type":"type","title":"Routex.Matchable.multi/0","doc":"","ref":"Routex.Matchable.html#t:multi/0"},{"type":"type","title":"Routex.Matchable.t/0","doc":"","ref":"Routex.Matchable.html#t:t/0"},{"type":"function","title":"Routex.Matchable.match?/2","doc":"Returns whether two Matchable records match on their route defining\nproperties. The first argument supports param en wildcard syntax\n(e.g \":param\" and \"*\").","ref":"Routex.Matchable.html#match?/2"},{"type":"function","title":"Example - Routex.Matchable.match?/2","doc":"iex> route_record = %Phoenix.Router.Route{path: \"/posts/:id\"} |> Routex.Matchable.new()\n    iex> matching_record = \"/posts/1/foo=bar#top\" |> Routex.Matchable.new()\n    iex> non_matching_record = \"/other/1/foo=bar#op\" |> Routex.Matchable.new()\n\n    iex> match?(route_record, matching_record)\n    true\n\n    iex match?(route_record, non_matching_record)\n    false","ref":"Routex.Matchable.html#match?/2-example"},{"type":"macro","title":"Routex.Matchable.matchable/1","doc":"","ref":"Routex.Matchable.html#matchable/1"},{"type":"macro","title":"Routex.Matchable.matchable/2","doc":"","ref":"Routex.Matchable.html#matchable/2"},{"type":"function","title":"Routex.Matchable.new/1","doc":"Converts a binary URL, `Phoenix.Router.Route` or (sigil) AST argument into a Matchable record.","ref":"Routex.Matchable.html#new/1"},{"type":"function","title":"Examples - Routex.Matchable.new/1","doc":"iex> path = \"/posts/1?foo=bar#top\"\n  iex> route = %Phoenix.Router.Route{path: \"/posts/:id\"}\n  iex> ast = {:<<>>, [], [\"/products/\", {:\"::\", [], [{{:., [], [Kernel, :to_string]}, [from_interpolation: true], [{:id, [], Elixir}]}, {:binary, [], Elixir}]}]}\n\n\tiex> path_match = Routex.Matchable.new(path)\n\t{:matchable, [nil], [\"posts\", \"1\"], \"foo=bar\", \"top\", false}\n\n\tiex> route_match = Routex.Matchable.new(route)\n\t{:matchable, [], [\"posts\", \":id\"], nil, nil, false}\n\n\tiex> ast_match = Routex.Matchable.new(ast)\n\t{:matchable, [], [\"posts\", {:\"::\", [], [{{:., [], [Kernel, :to_string]}, [from_interpolation: true], [{:id, [], Elixir}]}, {:binary, [], Elixir}]}], nil, nil, false}","ref":"Routex.Matchable.html#new/1-examples"},{"type":"function","title":"Routex.Matchable.to_ast_segments/1","doc":"Takes a record and returns a list of ast, each element matching one segment.","ref":"Routex.Matchable.html#to_ast_segments/1"},{"type":"function","title":"Routex.Matchable.to_func/4","doc":"Creates a function named `name` which the first argument matching\na Matchable record pattern. Other arguments can be given with either a\ncatch all or a pattern.\n\nThe Matchable pattern is bound to variable `pattern`","ref":"Routex.Matchable.html#to_func/4"},{"type":"function","title":"Example - Routex.Matchable.to_func/4","doc":"iex> \"/some/path\"\n       >  |> Matchable.new()\n       >  |> Matchable.to_func(:my_func, [pattern_arg: \"fixed\", :catchall_arg], quote(do: :ok))","ref":"Routex.Matchable.html#to_func/4-example"},{"type":"function","title":"Routex.Matchable.to_pattern/2","doc":"Returns a match pattern for given `Matchable` record or `Phoenix.Router.Route`.\nThe pattern can be used either as function argument or in a function body. As\nthe pattern binds values, the bindings can be used to convert input from one\npattern to another.","ref":"Routex.Matchable.html#to_pattern/2"},{"type":"function","title":"Examples - Routex.Matchable.to_pattern/2","doc":"iex> \"/original/:arg1/:arg2\" |> Routex.Matchable.new() |> Routex.Matchable.to_pattern()\n\t{:{}, [], [:matchable, {:hosts, [], Routex.Matchable}, [\"original\", {:arg1, [], Routex.Matchable}, {:arg2, [], Routex.Matchable}], {:query, [], Routex.Matchable}, {:fragment, [], Routex.Matchable}, false]}\n\n\tiex> \"/recomposed/:arg2/:arg1\" |> Routex.Matchable.new() |> Routex.Matchable.to_pattern()\n\t{:{}, [], [:matchable, {:hosts, [], Routex.Matchable}, [\"recomposed\", {:arg2, [], Routex.Matchable}, {:arg1, [], Routex.Matchable}], {:query, [], Routex.Matchable}, {:fragment, [], Routex.Matchable}, false]}\n\n\n\tiex> \"/original/segment_1/segment_2\" |> Routex.Matchable.new() |> Routex.Matchable.to_pattern()\n\t{:{}, [], [:matchable, {:hosts, [], Routex.Matchable}, [\"original\", \"segment_1\", \"segment_2\"], {:query, [], Routex.Matchable}, {:fragment, [], Routex.Matchable}, false]}","ref":"Routex.Matchable.html#to_pattern/2-examples"},{"type":"module","title":"Routex.Processing","doc":"This module provides everything needed to process Phoenix routes. It executes\nthe `transform` callbacks from extensions to transform `Phoenix.Router.Route`\nstructs and `create_helpers` callbacks to create one unified Helper module.\n\n**Powerful but thin**\nAlthough Routex is able to influence the routes in Phoenix applications in profound\nways, the framework and its extensions are a surprisingly lightweight piece\nof compile-time middleware. This is made possible by the way router modules\nare pre-processed by `Phoenix.Router` itself.\n\nPrior to compilation of a router module, Phoenix Router registers all routes\ndefined in the router module using the attribute `@phoenix_routes`. Each\nroute is at that stage a `Phoenix.Router.Route` struct.\n\nAny route enclosed in a `preprocess_using` block has received a `:private`\nfield in which Routex has put which Routex backend to use for that\nparticular route. By enumerating the routes, we can process each route using\nthe properties of this configuration and set struct values accordingly. This\nprocessing is nothing more than (re)mapping the Route structs' values.\n\nAfter the processing by Routex is finished, the `@phoenix_routes` attribute\nin the router is erased and re-populated with the list of mapped\nPhoenix.Router.Route structs.\n\nOnce the router module enters the compilation stage, Routex is already out of\nthe picture and route code generation is performed by Phoenix Router.","ref":"Routex.Processing.html"},{"type":"type","title":"Routex.Processing.extension_module/0","doc":"","ref":"Routex.Processing.html#t:extension_module/0"},{"type":"type","title":"Routex.Processing.helper_module/0","doc":"","ref":"Routex.Processing.html#t:helper_module/0"},{"type":"function","title":"Routex.Processing.__before_compile__/1","doc":"Callback executed before compilation of a `Phoenix Router`. This callback is added\nto the `@before_compile` callbacks by `Routex.Router`.","ref":"Routex.Processing.html#__before_compile__/1"},{"type":"function","title":"Routex.Processing.add_callbacks_map/1","doc":"","ref":"Routex.Processing.html#add_callbacks_map/1"},{"type":"function","title":"Routex.Processing.execute_callback/4","doc":"Executes the specified callback for an extension and returns the result.","ref":"Routex.Processing.html#execute_callback/4"},{"type":"function","title":"Routex.Processing.execute_callbacks/1","doc":"The main function of this module. Receives as only argument the environment of a\nPhoenix router module.","ref":"Routex.Processing.html#execute_callbacks/1"},{"type":"function","title":"Routex.Processing.execute_callbacks/2","doc":"","ref":"Routex.Processing.html#execute_callbacks/2"},{"type":"function","title":"Routex.Processing.transform_routes_per_backend/2","doc":"","ref":"Routex.Processing.html#transform_routes_per_backend/2"},{"type":"module","title":"Routex.Route","doc":"Function for working with Routex augmented Phoenix Routes","ref":"Routex.Route.html"},{"type":"function","title":"Routex.Route.exprs/2","doc":"Compatibility wrapper around `Phoenix.Router.Route.exprs`","ref":"Routex.Route.html#exprs/2"},{"type":"function","title":"Routex.Route.get_backends/1","doc":"Returns a list of unique backends","ref":"Routex.Route.html#get_backends/1"},{"type":"function","title":"Routex.Route.get_nesting/2","doc":"Returns the nesting level of an (ancestor) route. By default\nthe parent. This can be adjusted by providing an negative depth offset.","ref":"Routex.Route.html#get_nesting/2"},{"type":"function","title":"Routex.Route.group_by_method_and_origin/1","doc":"Returns routes grouped by the combination of method and origin path","ref":"Routex.Route.html#group_by_method_and_origin/1"},{"type":"function","title":"Routex.Route.group_by_method_and_path/2","doc":"","ref":"Routex.Route.html#group_by_method_and_path/2"},{"type":"function","title":"Routex.Route.group_by_nesting/2","doc":"Returns routes grouped by nesting level of an (ancestor) route. By default\ngroups by parent. This can be adjusted by providing an negative depth offset","ref":"Routex.Route.html#group_by_nesting/2"},{"type":"module","title":"Routex.Router","doc":"Provides macro (callbacks) to alter route definition before\ncompilation.\n\n> #### `use Routex.Router` {: .info}\n>\n> When you `use Routex.Router`, the Routex.Router module will\n> plug `Routex.Processing` between the definition of routes and the\n> compilation of the router module. It also imports the `preprocess_using`\n> macro which can be used to mark routes for Routex preprocessing using the\n> Routex backend provided as first argument.","ref":"Routex.Router.html"},{"type":"macro","title":"Routex.Router.preprocess_using/3","doc":"Wraps each enclosed route in a scope, marking it for processing by Routex\nusing given `backend`. `opts` can be used to partially override the given\nconfiguration.\n\nReplaces interpolation syntax with a string for macro free processing by\nextensions. Format: `[rtx.{binding}]`.","ref":"Routex.Router.html#preprocess_using/3"},{"type":"module","title":"Routex.Types","doc":"Types shared by Routex core and extensions.","ref":"Routex.Types.html"},{"type":"type","title":"Routex.Types.ast/0","doc":"","ref":"Routex.Types.html#t:ast/0"},{"type":"type","title":"Routex.Types.attrs/0","doc":"","ref":"Routex.Types.html#t:attrs/0"},{"type":"type","title":"Routex.Types.backend/0","doc":"","ref":"Routex.Types.html#t:backend/0"},{"type":"type","title":"Routex.Types.config/0","doc":"","ref":"Routex.Types.html#t:config/0"},{"type":"type","title":"Routex.Types.env/0","doc":"","ref":"Routex.Types.html#t:env/0"},{"type":"type","title":"Routex.Types.opts/0","doc":"","ref":"Routex.Types.html#t:opts/0"},{"type":"type","title":"Routex.Types.route/0","doc":"","ref":"Routex.Types.html#t:route/0"},{"type":"type","title":"Routex.Types.routes/0","doc":"","ref":"Routex.Types.html#t:routes/0"},{"type":"module","title":"Routex.Utils","doc":"Provides an interface to functions which can be used in extensions.","ref":"Routex.Utils.html"},{"type":"function","title":"Routex.Utils.alert/2","doc":"Prints an alert. Should be used when printing critical alerts in\nthe terminal during compile time.","ref":"Routex.Utils.html#alert/2"},{"type":"function","title":"Routex.Utils.assign_module/0","doc":"Returns the module to use for LiveView assignments","ref":"Routex.Utils.html#assign_module/0"},{"type":"function","title":"Routex.Utils.ensure_compiled!/1","doc":"Backward compatible version of `Code.ensure_compiled!/1`","ref":"Routex.Utils.html#ensure_compiled!/1"},{"type":"function","title":"Routex.Utils.get_attribute/3","doc":"Test env aware variant of Module.get_attribute. Delegates to\n`Module.get_attribute/3` in non-test environments. In test environment it\nreturns the result of `Module.get_attribute/3` or an empty list when the\nmodule is already compiled.","ref":"Routex.Utils.html#get_attribute/3"},{"type":"function","title":"Routex.Utils.get_branch_leaf/1","doc":"","ref":"Routex.Utils.html#get_branch_leaf/1"},{"type":"function","title":"Routex.Utils.get_branch_leaf_from_assigns/3","doc":"Returns the branch leaf from assigns.","ref":"Routex.Utils.html#get_branch_leaf_from_assigns/3"},{"type":"function","title":"Routex.Utils.get_helper_ast/1","doc":"Returns the AST to get the current branch leaf from process dict or from  assigns, conn or socket\nbased on the available variables in the `caller` module.","ref":"Routex.Utils.html#get_helper_ast/1"},{"type":"function","title":"Routex.Utils.print/2","doc":"Prints an indented text. Should be used when printing messages in\nthe terminal during compile time.","ref":"Routex.Utils.html#print/2"},{"type":"function","title":"Routex.Utils.process_put_branch/1","doc":"Helps setting the branch in the process dictionary.\n\n**Example: As dispatch target**\n\n```elixir\ndispatch_targets: [{Routex.Utils, :process_put_branch, [[:attrs, :__branch__]]}]\n```","ref":"Routex.Utils.html#process_put_branch/1"},{"type":"module","title":"Routex.Extension.AlternativeGetters","doc":"Creates helper functions to get a list of maps alternative slugs and their `Routex.Attrs`\nby providing a binary url. Sets `match?: true` for the url matching record.","ref":"Routex.Extension.AlternativeGetters.html"},{"type":"module","title":"Configuration - Routex.Extension.AlternativeGetters","doc":"```diff\n# file /lib/example_web/routex_backend.ex\ndefmodule ExampleWeb.RoutexBackend do\n  use Routex.Backend,\n  extensions: [\n    Routex.Extension.AttrGetters, # required\n    Routex.Extension.Alternatives,\n+   Routex.Extension.AlternativeGetters\n],\n```","ref":"Routex.Extension.AlternativeGetters.html#module-configuration"},{"type":"module","title":"Usage example - Routex.Extension.AlternativeGetters","doc":"```elixir\n<!-- @url is made available by Routex -->\n<!-- alternatives/1 is located in ExampleWeb.Router.RoutexHelpers aliased as Routes -->\n<.link\n   :for={alternative <- Routes.alternatives(@url)}\n   class=\"button\"\n   rel=\"alternate\"\n   hreflang={alternative.attrs.locale}\n   patch={alternative.slug}\n >\n   <.button class={(alternative.match? && \"highlighted\") || \"\"}>\n     <%= alternative.attrs.display_name %>\n   </.button>\n </.link>\n```","ref":"Routex.Extension.AlternativeGetters.html#module-usage-example"},{"type":"module","title":"Pseudo result - Routex.Extension.AlternativeGetters","doc":"```elixir\niex> ExampleWeb.Router.RoutexHelpers.alternatives(\"/products/12?foo=baz\")\n[ %Routex.Extension.AlternativeGetters{\n  slug: \"products/12/?foo=baz\",\n  match?: true,\n  attrs: %{\n    __branch__: [0, 12, 0],\n    __origin__: \"/products/:id\",\n    [...attributes set by other extensions...]\n  }},\n  %Routex.Extension.AlternativeGetters{\n  slug: \"/europe/products/12/?foo=baz\",\n  match?: false,\n  attrs: %{\n    __branch__: [0, 12, 1],\n    __origin__: \"/products/:id\",\n    [...attributes set by other extensions...]\n  }},\n %Routex.Extension.AlternativeGetters{\n  slug: \"/asia/products/12/?foo=baz\",\n  match?: false,\n  attrs: %{\n    __branch__: [0, 12, 1],\n    __origin__: \"/products/:id\",\n    [...attributes set by other extensions...]\n  }},\n]\n```\n\n## `Routex.Attrs`\n**Requires**\n- none\n\n**Sets**\n- none","ref":"Routex.Extension.AlternativeGetters.html#module-pseudo-result"},{"type":"module","title":"Helpers - Routex.Extension.AlternativeGetters","doc":"- alternatives(url :: String.t()) :: struct()","ref":"Routex.Extension.AlternativeGetters.html#module-helpers"},{"type":"module","title":"Routex.Extension.Alternatives","doc":"Creates alternative routes based on `branches` configured in a Routex backend\nmodule. Branches can be nested and each branch can provide `Routex.Attrs` to be shared\nwith other extensions.\n\n> #### In combination with... {: .neutral}\n> How to combine this extension for localization is written in de [Localization Guide](guides/LOCALIZE_PHOENIX.md)","ref":"Routex.Extension.Alternatives.html"},{"type":"module","title":"Configuration - Routex.Extension.Alternatives","doc":"```diff\n# file /lib/example_web/routex_backend.ex\n# This example uses a `Struct` for custom attributes, so there is no attribute inheritance;\n# only struct defaults. When using maps, nested branches will inherit attributes from their parent.\n\n+ defmodule ExampleWeb.RoutexBackend.AltAttrs do\n+  @moduledoc false\n+  defstruct [:contact, locale: \"en\"]\n+ end\n\ndefmodule ExampleWeb.RoutexBackend do\n+ alias ExampleWeb.RoutexBackend.AltAttrs\n\nuse Routex.Backend,\nextensions: [\n  Routex.Extension.AttrGetters, # required\n+ Routex.Extension.Alternatives,\nRoutex.Extension.AttrGetters\n],\n+ alternatives: %{\n+    \"/\" => %{\n+      attrs: %AltAttrs{contact: \"root@example.com\"},\n+      branches: %{\n+        \"/europe\" => %{\n+          attrs: %AltAttrs{contact: \"europe@example.com\"},\n+          branches: %{\n+            \"/nl\" => %{attrs: %AltAttrs{locale: \"nl\", contact: \"verkoop@example.nl\"}},\n+            \"/be\" => %{attrs: %AltAttrs{locale: \"nl\", contact: \"handel@example.be\"}}\n+          }\n+        },\n+      \"/gb\" => %{attrs: %AltAttrs{contact: \"sales@example.com\"}\n+    }\n+  },\n+ alternatives_prefix: false  # whether to automatically prefix routes, defaults to true\n```","ref":"Routex.Extension.Alternatives.html#module-configuration"},{"type":"module","title":"Pseudo result - Routex.Extension.Alternatives","doc":"```elixir\n    Router              Generated                         Attributes\n                        ⇒ /products/:id/edit              locale: \"en\", contact: \"rootexample.com\"\n    /products/:id/edit  ⇒ /europe/nl/products/:id/edit    locale: \"nl\", contact: \"verkoop@example.nl\"\n                        ⇒ /europe/be/products/:id/edit    locale: \"nl\", contact: \"handel@example.be\"\n                        ⇒ /gb/products/:id/edit           locale: \"en\", contact: \"sales@example.com\"\n ```\n\n## `Routex.Attrs`\n**Requires**\n- none\n\n**Sets**\n- **any key/value in `:attrs`**\n- branch_helper\n- branch_alias\n- branch_prefix\n- branch_opts\n- alternatives (list of `Phoenix.Route.Route`)","ref":"Routex.Extension.Alternatives.html#module-pseudo-result"},{"type":"module","title":"Routex.Extension.Assigns","doc":"Extracts `Routex.Attrs` from a route and makes them available in components\nand controllers with the assigns operator `@` (optionally under a namespace).\n\n> #### In combination with... {: .neutral}\n> Other extensions set `Routex.Attrs`. The attributes an extension sets is listed in it's documentation.\n> To define custom attributes for routes have a look at `Routex.Extension.Alternatives`","ref":"Routex.Extension.Assigns.html"},{"type":"module","title":"Options - Routex.Extension.Assigns","doc":"- `namespace`: when set creates a named collection: assigns available as @namespace.key\n- `attrs`: If attrs is not set, all Routex.Attrs are included. If attrs is set\n  to a list of keys, only the specified subset of attributes will be\n  available.","ref":"Routex.Extension.Assigns.html#module-options"},{"type":"module","title":"Configuration - Routex.Extension.Assigns","doc":"```diff\n# file /lib/example_web/routex_backend.ex\ndefmodule ExampleWeb.RoutexBackend do\n  use Routex.Backend,\n  extensions: [\n    Routex.Extension.AttrGetters, # required\n+   Routex.Extension.Assigns\n],\n+ assigns: %{namespace: :rtx, attrs: [:branch_helper, :locale, :contact, :name]}\n```","ref":"Routex.Extension.Assigns.html#module-configuration"},{"type":"module","title":"Pseudo result - Routex.Extension.Assigns","doc":"# in (h)eex template\n    @rtx.branch_helper  ⇒  \"eu_nl\"\n    @rtx.locale         ⇒  \"nl\"\n    @rtx.contact        ⇒  \"verkoop@example.nl\"\n    @rtx.name           ⇒  \"The Netherlands\"\n\n## `Routex.Attrs`\n**Requires**\n- none\n\n**Sets**\n- assigns","ref":"Routex.Extension.Assigns.html#module-pseudo-result"},{"type":"module","title":"Example use case - Routex.Extension.Assigns","doc":"Combine with `Routex.Extension.Alternatives` to make compile time, branch\nbound assigns available to components and controllers.","ref":"Routex.Extension.Assigns.html#module-example-use-case"},{"type":"function","title":"Routex.Extension.Assigns.handle_params/3","doc":"Hook attached to the `handle_params` stage in the LiveView life cycle","ref":"Routex.Extension.Assigns.html#handle_params/3"},{"type":"module","title":"Routex.Extension.AttrGetters","doc":"Access route attributes at runtime within your controllers, plugs, or LiveViews\nbased on the matched route's properties. Uses pattern matching for optimal\nperformance during runtime.\n\nThis extension provides the required `attrs/1` helper function, used by\nRoutex to assign helper attributes in the generated `on_mount/4` callback.\n\n> #### In combination with... {: .neutral}\n> Other extensions set `Routex.Attrs`. The attributes an extension sets is listed in it's documentation.\n> To define custom attributes for routes have a look at `Routex.Extension.Alternatives`","ref":"Routex.Extension.AttrGetters.html"},{"type":"module","title":"Configuration - Routex.Extension.AttrGetters","doc":"```diff\n# file /lib/example_web/routex_backend.ex\ndefmodule ExampleWeb.RoutexBackend do\n  use Routex.Backend,\n  extensions: [\n+   Routex.Extension.AttrGetters,  # required\n],\n```","ref":"Routex.Extension.AttrGetters.html#module-configuration"},{"type":"module","title":"Pseudo result - Routex.Extension.AttrGetters","doc":"```elixir\niex> ExampleWeb.Router.RoutexHelpers.attrs(\"/europe/nl/producten/?foo=baz\")\n%{\n  __branch__: [0, 9, 3],\n  __origin__: \"/products\",\n  backend: ExampleWeb.LocalizedRoutes,\n  contact: \"verkoop@example.nl\",\n  locale: \"nl\",\n  branch_name: \"The Netherlands\",\n  branch_helper: \"europe_nl\",\n}\n```\n\n## `Routex.Attrs`\n**Requires**\n- none\n\n**Sets**\n- none","ref":"Routex.Extension.AttrGetters.html#module-pseudo-result"},{"type":"module","title":"Helpers - Routex.Extension.AttrGetters","doc":"- attrs(url :: binary) :: map()","ref":"Routex.Extension.AttrGetters.html#module-helpers"},{"type":"module","title":"Routex.Extension.Cldr","doc":"Adapter for projects using :ex_cldr. It generates configuration for locale routes\nbased on your existing Cldr setup for a seamless experience.\n\n > #### Have a look at.... {: .neutral}\n> This adapter was developed before `Routex.Extension.Localize.Phoenix` -a\n> powerful localization extension which automatically integrates with your existing Cldr-setup.\n> You might also be interested in our guide [Localize Phoenix](/docs/guides/LOCALIZE_PHOENIX.md).","ref":"Routex.Extension.Cldr.html"},{"type":"module","title":"Interpolating Locale Data - Routex.Extension.Cldr","doc":"Interpolation is provided by `Routex.Extension.Interpolation`, which\nis able to use any `Routex.Attr` for interpolation into your routes.\nSee it's documentation for additional options.\n\nWhen using this Cldr extension, the following interpolations are supported as they\nare set as `Routex.Attr`:\n\n* `locale` will interpolate the Cldr locale name\n* `locale_display` will interpolate the Cldr locale display name\n* `language` will interpolate the Cldr language name\n* `territory` will interpolate the Cldr territory code\n\nSome examples:\n```elixir\npreprocess_using ExampleWeb.RoutexBackend do\n  scope \"/#{territory}/territory/\" do\n    get \"/locale/pages/:page/#{locale}/\", PageController, :show\n    get \"/language/#{language}/pages/:page\", PageController, :show\n  end\nend\n```","ref":"Routex.Extension.Cldr.html#module-interpolating-locale-data"},{"type":"module","title":"Configuration - Routex.Extension.Cldr","doc":"> #### Ejecting the CLDR extension {: .neutral}\n> Using the Cldr adapter provides the advantage of keeping your localized routes\n> in sync with the configuration of Cldr. The disadvantage is a lack of flexibility.\n> If you ever need more flexibility, you can [eject the Cldr extension](#module-eject-the-cldr-adapter).\n\n\n```diff\ndefmodule ExampleWeb.RoutexBackend do\nuse Routex.Backend,\nextensions: [\n  # required\n   Routex.Extension.AttrGetters,\n\n  # adviced\n  Routex.Extension.AlternativeGetters,\n  Routex.Extension.Assigns,\n\n  # the adapter with dependency\n  Routex.Extension.Cldr,\n  Routex.Extension.Alternatives,\n\n  # replacements for cldr-routes\n  Routex.Extension.VerifiedRoutes,\n  Routex.Extension.Interpolation, #  when using routes with interpolation\n  Routex.Extension.Translations,  # when using translated routes\n\n  # replacements for cldr-plugs\n  Routex.Extension.LiveViewHooks,\n  Routex.Extension.Plugs,\n  Routex.Extension.Localize.Phoenix.Runtime,\n\n  # control Cldr locale at runtime\n  Routex.Extension.RuntimeDispatcher,\n],\n+ cldr_backend: MyApp.Cldr,\n+ translations_backend: MyApp.Gettext,  #  when using translated routes\n+ translations_domain: \"routes\",  #  when using translated routes\n+ alternatives_prefix: false,  #  when using routes with interpolation\n+ verified_sigil_routex: \"~q\", #  consider using ~p, see `Routex.Extension.VerifiedRoutes`\n+ dispatch_targets: [\n+   # Set CLDR locale from :locale attribute\n+   {Cldr, :put_locale, [MyApp.Cldr, [:attrs, :locale]]}\n+ ]\nend\n```\n\n```diff\ndefmodule ExampleWeb.Router\n# require your Cldr backend module before `use`ing the router.\n+ require ExampleWeb.Cldr\n\nuse ExampleWeb, :router\n\nimport ExampleWeb.UserAuth\n```\n\nWhen your application does not compile after adding this extension, force a\nrecompile using `mix compile --force`.","ref":"Routex.Extension.Cldr.html#module-configuration"},{"type":"module","title":"Pseudo result - Routex.Extension.Cldr","doc":"This extension injects `:alternatives` into your configuration.\n See the documentation of `Routex.Extension.Alternatives` to see\n more options and the pseudo result.","ref":"Routex.Extension.Cldr.html#module-pseudo-result"},{"type":"module","title":"Eject the Cldr adapter - Routex.Extension.Cldr","doc":"This extension abstracts away the configuration of `Routex.Extension.Alternatives`. You may want\nto customize things beyond what `Routex.Extension.Cldr` provides. When you eject, you copy\nthe generated configuration into the Routex backend.\n\nIn other words, instead of relying on the preconfigured “black box” provided by this extension, you\nnow have full access to—and responsibility for—the configuration of `Routex.Extension.Alternatives`.\n\n#### Copy the generated configuration into your Routex backend**\n\nCall the `config/0` function on you backend (e.g. `ExampleWeb.RoutexBackend.config()`)\nin IEX. Copy the `alternatives: %{...}` section to your Routex backend.\n\n```diff\ndefmodule ExampleWeb.RoutexBackend do\nuse Routex.Backend,\nextensions: [...],\n+ alternatives: %{...}\n```\n\n#### Remove references to Cldr\n\n```diff\ndefmodule ExampleWeb.RoutexBackend do\nuse Routex.Backend,\nextensions: [\n-  Routex.Extension.Cldr,\n],\n- cldr_backend: MyApp.Cldr,\n```\n\n```diff\ndefmodule ExampleWeb.Router\n- require ExampleWeb.Cldr\n\nuse ExampleWeb, :router\n\nimport ExampleWeb.UserAuth\n```\n\n## `Routex.Attrs`\n**Requires**\n- none\n\n**Sets**\n- language\n- locale\n- locale_display\n- territory","ref":"Routex.Extension.Cldr.html#module-eject-the-cldr-adapter"},{"type":"function","title":"Routex.Extension.Cldr.configure/2","doc":"Callback implementation for  Routex.Extension.configure/2 .","ref":"Routex.Extension.Cldr.html#configure/2"},{"type":"module","title":"Routex.Extension.Cloak","doc":"Transforms routes to be unrecognizable.\n\n\n> #### Warning {: .warning}\n>\n> This extension is intended for testing and demonstration. It may change at\n> any given moment to generate other routes without prior notice.\n\n\nThe Cloak extension demonstrates how Routex enables extensions to transform\nroutes beyond recognition without breaking Phoenix' native and Routex' routing\nfeatures.\n\nCurrently it numbers all routes. Starting at 1 and incremening the counter for\neach route. It also shifts the parameter to the left; causing a chaotic route\nstructure.\n\nDo note: this still works with the Verified Routes extension. You can use the\noriginal, non transformed, routes in templates (e.g. `~p\"/products/%{product}\"`)\nand still be sure the transformed routes rendered at runtime (e.g. `/88/2` when product.id = 88)\nare valid routes.","ref":"Routex.Extension.Cloak.html"},{"type":"module","title":"Do (not) try this at home - Routex.Extension.Cloak","doc":"- Try this extension with a route generating extension like\n`Routex.Extension.Alternatives` for even more chaos.\n\n- Adapt this extension to use character repetition instead of numbers. Can you\nguess where `/90/!!` brings to?","ref":"Routex.Extension.Cloak.html#module-do-not-try-this-at-home"},{"type":"module","title":"Options - Routex.Extension.Cloak","doc":"- `cloak`: Binary to duplicate or tuple with {module, function, arguments} which will receive a\nindex counter as first argument.","ref":"Routex.Extension.Cloak.html#module-options"},{"type":"module","title":"Configuration - Routex.Extension.Cloak","doc":"```diff\n# file /lib/example_web/routex_backend.ex\ndefmodule ExampleWeb.RoutexBackend do\n  use Routex.Backend,\n  extensions: [\n   Routex.Extension.AttrGetters, # required\n+  Routex.Extension.Cloak\n],\ncloak: \"!\"\n```","ref":"Routex.Extension.Cloak.html#module-configuration"},{"type":"module","title":"Pseudo result - Routex.Extension.Cloak","doc":"Original                 Rewritten    Result (product_id: 88, 89, 90)\n    /products                ⇒     /1     ⇒    /1\n    /products/:id/edit       ⇒ /:id/2     ⇒ /88/2, /89/2, /90/2 etc...\n    /products/:id/show/edit  ⇒ /:id/3     ⇒ /88/3, /89/3, /90/3 etc...\n\n\n## `Routex.Attrs`\n**Requires**\n- none\n\n**Sets**\n- none","ref":"Routex.Extension.Cloak.html#module-pseudo-result"},{"type":"function","title":"Routex.Extension.Cloak.binary_transform/3","doc":"","ref":"Routex.Extension.Cloak.html#binary_transform/3"},{"type":"function","title":"Routex.Extension.Cloak.default_transform/3","doc":"","ref":"Routex.Extension.Cloak.html#default_transform/3"},{"type":"function","title":"Routex.Extension.Cloak.function_transform/3","doc":"","ref":"Routex.Extension.Cloak.html#function_transform/3"},{"type":"module","title":"Routex.Extension.Interpolation","doc":"A route may be defined with a routes `Routex.Attrs` interpolated\ninto it. These interpolations are specified using the usual `#{variable}`\ninterpolation syntax. Unlike some other routing solutions, interpolation\nis *not* restricted to the beginning of routes.\n\n> #### In combination with... {: .neutral}\n> Other extensions set `Routex.Attrs`. The attributes an extension sets is listed in it's documentation.\n> To define custom attributes for routes have a look at `Routex.Extension.Alternatives`\n>\n> When using `Routex.Extension.Alternatives` you might\n> want to disable auto prefixing for the whole Routex backend (see\n> `Routex.Extension.Alternatives`) or per route (see `Routex`).\n\n> #### Bare base route {: .warning}\n> The route as specified in the Router will be stripped from any\n> interpolation syntax. This allows you to use routes without interpolation\n> syntax in your templates (e.g. ~p\"/products\") and have them verified by\n> Verified Routes. The routes will be rendered with interpolated attributes\n> at run time.","ref":"Routex.Extension.Interpolation.html"},{"type":"module","title":"Configuration - Routex.Extension.Interpolation","doc":"none","ref":"Routex.Extension.Interpolation.html#module-configuration"},{"type":"module","title":"Usage - Routex.Extension.Interpolation","doc":"```elixir\n# file /lib/example_web/routes.ex\nlive \"/products/#{locale}/:id\", ProductLive.Index, :index\n```","ref":"Routex.Extension.Interpolation.html#module-usage"},{"type":"module","title":"Pseudo result - Routex.Extension.Interpolation","doc":"```elixir\n    # in combination with Routex.Extension.Alternatives with auto prefix\n    # disabled and 3 branches. It splits the routes and sets the :locale\n    # attribute which is used for interpolation.\n\n    Route                      Generated\n                               ⇒ /products/en/:id\n    /products/#{locale}/:id/   ⇒ /products/fr/:id\n                               ⇒ /products/fr/:id\n```\n\n## `Routex.Attrs`\n**Requires**\n- none\n\n**Sets**\n- none","ref":"Routex.Extension.Interpolation.html#module-pseudo-result"},{"type":"module","title":"Routex.Extension.LiveViewHooks","doc":"Attach LiveView hooks provided by Routex extensions.\n\nThis extension generates quoted functions to inject into LiveView's\nlifecycle stages. The hooks are built from a set of supported lifecycle\ncallbacks provided by extensions.\n\nThe arguments given to these callbacks adhere to the official\nspecifications.","ref":"Routex.Extension.LiveViewHooks.html"},{"type":"function","title":"Routex.Extension.LiveViewHooks.configure/2","doc":"Detect supported lifecycle callbacks in extensions and adds\nthem to `opts[:hooks]`.\n\nDetects and registers supported lifecycle callbacks from other extensions.\nReturns an updated keyword list with the valid callbacks accumulated\nunder the `:hooks` key.\n\n**Supported callbacks:**\n[handle_params: [:params, :uri, :socket], handle_event: [:event, :params, :socket], handle_info: [:msg, :socket], handle_async: [:name, :async_fun_result, :socket]]","ref":"Routex.Extension.LiveViewHooks.html#configure/2"},{"type":"function","title":"Routex.Extension.LiveViewHooks.create_shared_helpers/3","doc":"Generates Routex' LiveView `on_mount/4` hook, which inlines the lifecycle\nstage hooks provided by other extensions.\n\nReturns  `on_mount/4` and an initial `handle_params/3`.","ref":"Routex.Extension.LiveViewHooks.html#create_shared_helpers/3"},{"type":"module","title":"Routex.Extension.Localize.Phoenix","doc":"Localize your Phoenix with minimal configuration.\n\nAdd `Routex.Extension.Localize.Phoenix.Routes`\nand `Routex.Extension.Localize.Phoenix.Runtime` to\nthe list of extensions.\n\nFor configuration options and additional details, refer to their\ndocumentation.","ref":"Routex.Extension.Localize.Phoenix.html"},{"type":"module","title":"Routex.Extension.Localize.Phoenix.Routes","doc":"Localize Phoenix routes using simple configuration.\n\nAt compile time, this extension generates localized routes based on locale\ntags. These locale tags are automatically derived from your Cldr, Gettext or\nFluent setup and can be overriden using the extensions options.\n\nWhen using a custom configuration, tags are validated using a\n[build-in locale registry](Routex.Extension.Localize.Registry)\nbased on the authoritive\n[IANA Language Subtag Registry](https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry).","ref":"Routex.Extension.Localize.Phoenix.Routes.html"},{"type":"module","title":"Automated locale expansion - Routex.Extension.Localize.Phoenix.Routes","doc":"At compile time this extension will expand a routes `:locale` attribute into\nmultiple locale attributes using the build-in registry:\n\n- `:locale` (e.g., \"en-US\")\n- `:language` (e.g., \"en\")\n- `:region` (e.g., \"US\")\n- `:language_display_name` (e.g., \"English\")\n- `:region_display_name` (e.g., \"United States\")","ref":"Routex.Extension.Localize.Phoenix.Routes.html#module-automated-locale-expansion"},{"type":"module","title":"Options - Routex.Extension.Localize.Phoenix.Routes","doc":"- `locales`: A list of locale definitions. Defaults to known locales\n   by Cldr, Gettext or Fluent (in that order).\n\n   Each entry can be:\n   - A locale tag (e.g., `\"en\"`, `\"fr-CA\"`).\n   - A keyword tuple `locale: attrs` with attributes map for that specific locale branch.\n\n   **Example:**\n   ```elixir\n   locales: [\n     # Standard English\n     \"en\",\n     # Standard French\n     \"fr\"\n     # Language: \"English\", Region: \"Global\" displayed as \"Worldwide\"\n     \"en-001\": %{region_display_name: \"Worldwide\"},\n     # Language: \"English\", Region: \"Great Brittain\", Compile time route attributes: %{currency: \"GBP\"}\n     \"en-GB\": %{currency: \"GBP\"},\n   ]\n   ```\n\n   > #### Attribute Merging Precedence (Compile Time, low to high):\n   > 1. Derived from locale string\n   > 2. Explicit Locale Override (from attrs in tuple)\n   > 3. Original Branch Attribute (already existing on the branch)\n   >\n   > Point 3 ensures this extension plays well with\n   > pre-configured alternative branches.\n\n- `default_locale`: The locale for top-level routes (e.g., `/products`).\n   Default to the default locale of Cldr, Gettext or Fluent (in that order) with\n   fallback to \"en\".\n\n- `locale_backend`: Backend to use for Cldr, Gettext or Fluent. Defaults to their\n   own backend module name convensions.\n\n- `locale_prefix_sources`: Single atom or list of locale attributes to prefix\n   routes with. Will use the first (sub)tag which returns a non-nil value.\n   When no value is found the locale won't have localized routes.\n\n   Possible values: `:locale`, `:region`, `:language`, `:language_display_name`, `:region_display_name`.\n   Default to: `[:language, :region, :locale]`.\n\n   **Examples:**\n    ```elixir\n    # in configuration\n    locales: [\"en-001\", \"fr\", \"nl-NL\", \"nl-BE\"]\n    default_locale: \"en\"\n\n    # single source\n    locale_prefix_sources: :locale =>     [\"/\", \"/en-001\", \"/fr\", \"/nl/nl\", \"/nl-be\"],\n    locale_prefix_sources: :language => [\"/\", \"/fr\", \"/nl\"],\n    locale_prefix_sources: :region =>     [\"/\", \"/001\", \"/nl\", \"/be\"]\n    locale_prefix_sources: :language_display_name =>     [\"/\", \"/english\", \"/french\", \"/dutch\"]\n    locale_prefix_sources: :region_display_name =>     [\"/\", \"/world\", \"/france\", \"/netherlands\", \"/belgium\"]\n\n    # with fallback\n    locale_prefix_sources: [:language, :region] => [\"/\", \"/fr\", \"/nl\"]\n    locale_prefix_sources: [:region, :language] => [\"/\", \"/001\", \"/fr\", \"/nl\", \"/be\"]\n\n    ```","ref":"Routex.Extension.Localize.Phoenix.Routes.html#module-options"},{"type":"module","title":"Configuration examples - Routex.Extension.Localize.Phoenix.Routes","doc":"> **Together with...**\n> This extension generates configuration for alternative route branches under the `:alternatives` key.\n> To convert these into routes, `Routex.Extension.Alternatives` is automatically enabled.\n\n> **Integration:**\n> This extension sets runtime attributes (`Routex.Attrs`).\n> To use these attributes in libraries such as Gettext and Cldr, see\n> `Routex.Extension.RuntimeDispatcher`.\n\n#### Simple Backend Configuration\nThis extensions ships with sane default for the most common\nuse cases. As a result configuration is only used for overrides.\n\n**Example:**\n```elixir\ndefmodule ExampleWeb.RoutexBackend do\n  use Routex.Backend,\n    extensions: [\n      Routex.Extension.Attrs,\n      Routex.Extension.Localize.Phoenix.Routes,\n      Routex.Extension.RuntimeDispatcher # Optional: for state depending package integration\n    ],\n    # This option is shared with the Translations extension\n     :translations_backend: ExampleWeb.Gettext,\n    # RuntimeDispatcher options\n    dispatch_targets: [\n      {Gettext, :put_locale, [[:attrs, :language]]},\n      # {Cldr, :put_locale, [[:attrs, :locale]]}\n    ]\nend\n```\n\n#### Advanced Backend Configuration\nDue to a fair amount of powerful options, you can tailor the localization to\ncustom requirements.\n\n**Example:**\n```elixir\ndefmodule ExampleWeb.RoutexBackend do\n  use Routex.Backend,\n    extensions: [\n      Routex.Extension.Attrs,\n      # Enable Localize for localized routes\n      Routex.Extension.Localize.Phoenix.Routes,\n      Routex.Extension.RuntimeDispatcher\n    ],\n    # Compile-time options for Localize.Beta\n    locales: [\"en\", \"fr\", {\"nl\", %{region_display_name: \"Nederland\"}}],\n    default_locale: \"en\",\n    locale_prefix_sources: [:language],\n\n    # Runtime detection overrides for Localize.Beta\n    locale_sources: [:query, :session, :accept_language, :attrs],\n    locale_params: [\"locale\", \"lang\"],\n    language_sources: [:path, :attrs],\n    language_params: [\"lang\"],\n\n    # Runtime dispatch targets used by RuntimeDispatcher\n    dispatch_targets: [\n      {Gettext, :put_locale, [[:attrs, :language]]},\n      {Cldr, :put_locale, [[:attrs, :locale]]}\n    ]\nend\n```","ref":"Routex.Extension.Localize.Phoenix.Routes.html#module-configuration-examples"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Routes.attributes/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Routes.html#t:attributes/0"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Routes.locale/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Routes.html#t:locale/0"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Routes.locale_attribute_key/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Routes.html#t:locale_attribute_key/0"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Routes.locale_attribute_keys/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Routes.html#t:locale_attribute_keys/0"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Routes.locale_attributes/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Routes.html#t:locale_attributes/0"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Routes.locale_definition/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Routes.html#t:locale_definition/0"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Routes.prefix_source/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Routes.html#t:prefix_source/0"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Routes.prefix_sources/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Routes.html#t:prefix_sources/0"},{"type":"module","title":"Routex.Extension.Localize.Phoenix.Runtime","doc":"This extension provides:\n\n- A Plug (`plug/3`) to update the connection with locale attributes and store them\n  in the session. Enabled via `Routex.Extension.Plugs`.\n- A LiveView lifecycle hook (`handle_params/4`) to update the socket with\n  locale-related attributes. Enabled via `Routex.Extension.LiveViewHooks`.\n\nBoth are optimized for performance.\n\nLocale values can be sourced independently from locations like:\n\n- Pre-compiled route attributes\n- The `Accept-Language` header sent by the client (`fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7`)\n- Query parameters (`?lang=fr`)\n- Hostname (`fr.example.com`)\n- Path parameters (`/fr/products`)\n- Assigns (`assign(socket, [locale: \"fr\"])`)\n- Body parameters\n- Stored cookie\n- Session data\n\n\nRuntime detection is configured by specifying sources for locale attributes\n(`:locale`, `:language`, `:region`).\n\n#### Locale Attributes and Their Sources\n\nEach attribute (`:locale`, `:language`, `:region`) can have its own list of\nsources and parameter names, where the parameter name is the key to get from\nthe source. The parameter should be provided as a string.\n\n##### Supported Sources\n- `:accept_language`: From the header sent by the client (e.g. `fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7`)\n- `:assigns`: From conn and socket assigns.\n- `:route`: From precompiled route attributes.\n- `:body`: From request body parameters.\n- `:cookie`: From request cookies.\n- `:host`: From the hostname (e.g., `en.example.com`).\n- `:path`: From path parameters (e.g., `/:lang/users`).\n- `:query`: From query parameters (e.g., `?locale=de`).\n- `:session`: From session data.\n\n##### Default Configuration\n\nThe default sources for each attribute are:\n`[:query, :session, :cookie, :accept_language, :path, :assigns, :route]`.\n\n##### Overriding Detection Behavior\n\nYou can customize sources and parameters per attribute:\n\n**Examples:**\n```elixir\n# In your Routex backend module\nlocale_sources: [:query, :session, :accept_language], # Order matters\nlocale_params: [\"locale\"], # Look for ?locale=... etc\n\nlanguage_sources: [:path, :host],\nlanguage_params: [\"lang\"], # Look for /:lang/... etc\n\nregion_sources: [:route] # Only use region from precompiled route attributes\n# region_params defaults to [\"region\"]\n```","ref":"Routex.Extension.Localize.Phoenix.Runtime.html"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Runtime.conn/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Runtime.html#t:conn/0"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Runtime.params/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Runtime.html#t:params/0"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Runtime.plug_opts/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Runtime.html#t:plug_opts/0"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Runtime.socket/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Runtime.html#t:socket/0"},{"type":"type","title":"Routex.Extension.Localize.Phoenix.Runtime.url/0","doc":"","ref":"Routex.Extension.Localize.Phoenix.Runtime.html#t:url/0"},{"type":"function","title":"Routex.Extension.Localize.Phoenix.Runtime.call/2","doc":"Plug callback to detect and assign locale attributes to the connection.\n\nExamines configured sources (params, session, headers, etc.), updates\n`conn.assigns`, merges attributes into `conn.private.routex.attrs`, and\npersists relevant attributes in the session.","ref":"Routex.Extension.Localize.Phoenix.Runtime.html#call/2"},{"type":"function","title":"Routex.Extension.Localize.Phoenix.Runtime.configure/2","doc":"Checks for invalid sources","ref":"Routex.Extension.Localize.Phoenix.Runtime.html#configure/2"},{"type":"function","title":"Routex.Extension.Localize.Phoenix.Runtime.handle_params/3","doc":"LiveView `handle_params/4` callback hook.\n\nDetects locale settings based on URL, params, and socket state, then updates\nthe socket assigns and Routex attributes.","ref":"Routex.Extension.Localize.Phoenix.Runtime.html#handle_params/3"},{"type":"module","title":"Routex.Extension.Plugs","doc":"Provides integration for plugs defined by Routex extensions.\n\nDetect extensions that implement supported plug callbacks. The valid plug\ncallbacks are then collected and attached to the options under the `:plugs`\nkey. Additionally, the module generates a Routex Plug hook that inlines the\nplugs provided by these extensions so that they are invoked in a single plug\nchain.","ref":"Routex.Extension.Plugs.html"},{"type":"function","title":"Routex.Extension.Plugs.configure/2","doc":"Detects and registers supported plug callbacks from other extensions.\nReturns an updated keyword list with the valid plug callbacks accumulated\nunder the `:plugs` key.\n\n**Supported callbacks:**\n- `call/2`: `Plug.Conn.call/2`","ref":"Routex.Extension.Plugs.html#configure/2"},{"type":"function","title":"Routex.Extension.Plugs.create_shared_helpers/3","doc":"Generates a plug hook for Routex that inlines plugs provided by other extensions.\n\nThis helper function creates quoted expressions defining a plug function that\nencapsulates all the plug callbacks registered by Routex extension backends.","ref":"Routex.Extension.Plugs.html#create_shared_helpers/3"},{"type":"module","title":"Routex.Extension.RouteHelpers","doc":"This module provides route helpers that support the automatic selection of\nalternative routes. These helpers can serve as drop-in replacements for\nPhoenix's default route helpers.\n\nUse this extension only if your application leverages extensions that\ngenerate alternative routes. Otherwise, the result will be identical to the\nofficial helpers provided by Phoenix.","ref":"Routex.Extension.RouteHelpers.html"},{"type":"module","title":"Configuration - Routex.Extension.RouteHelpers","doc":"In versions of Phoenix prior to 1.7, an alias `Routes` was created by\ndefault. You can either replace this alias or add an alias for\n`RoutexHelpers`. Note that Phoenix 1.7 and later have deprecated these\nhelpers in favor of Verified Routes.\n\nIn the example below, we override the default `Routes` alias to use Routex's\nRoute Helpers as a drop-in replacement, while keeping the original helper\nfunctions available under the alias `OriginalRoutes`:\n\n```diff\n# file /lib/example_web.ex\ndefp routex_helpers do\n+ alias ExampleWeb.Router.Helpers, as: OriginalRoutes\n+ alias ExampleWeb.Router.RoutexHelpers, as: Routes\nend\n```","ref":"Routex.Extension.RouteHelpers.html#module-configuration"},{"type":"module","title":"Pseudo Result - Routex.Extension.RouteHelpers","doc":"When alternative routes are created, auto-selection is used to keep the user\nwithin a specific branch.","ref":"Routex.Extension.RouteHelpers.html#module-pseudo-result"},{"type":"module","title":"Example in a (h)eex template: - Routex.Extension.RouteHelpers","doc":"```heex\n Product #1 \n```","ref":"Routex.Extension.RouteHelpers.html#module-example-in-a-h-eex-template"},{"type":"module","title":"Result after compilation: - Routex.Extension.RouteHelpers","doc":"```elixir\ncase alternative do\n   nil ⇒  \"/products/#{product}\"\n  \"en\" ⇒  \"/products/#{product}\"\n  \"nl\" ⇒  \"/europe/nl/products/#{product}\"\n  \"be\" ⇒  \"/europe/be/products/#{product}\"\nend\n```\n\n## `Routex.Attrs`\n\n**Requires:**\n- None\n\n**Sets:**\n- None","ref":"Routex.Extension.RouteHelpers.html#module-result-after-compilation"},{"type":"type","title":"Routex.Extension.RouteHelpers.helper_module/0","doc":"","ref":"Routex.Extension.RouteHelpers.html#t:helper_module/0"},{"type":"function","title":"Routex.Extension.RouteHelpers.create_helpers/3","doc":"Creates the route helpers for the given routes if the `:phoenix_helpers`\nattribute is set.","ref":"Routex.Extension.RouteHelpers.html#create_helpers/3"},{"type":"function","title":"Parameters - Routex.Extension.RouteHelpers.create_helpers/3","doc":"- `routes`: The list of routes to create helpers for.\n- `backend`: The backend module (not used).\n- `env`: The macro environment.","ref":"Routex.Extension.RouteHelpers.html#create_helpers/3-parameters"},{"type":"function","title":"Returns - Routex.Extension.RouteHelpers.create_helpers/3","doc":"A list of quoted expressions representing the generated helpers.","ref":"Routex.Extension.RouteHelpers.html#create_helpers/3-returns"},{"type":"module","title":"Routex.Extension.RuntimeDispatcher","doc":"The `Routex.Extension.RuntimeDispatcher` enables the dynamic dispatching of\nfunctions to external libraries or modules during the Plug pipeline and\nLiveView's `handle_params`. This dispatching is configured using a list of\n`{module, function, arguments}` tuples and leverages attributes from\n`Routex.Attrs` at runtime.\n\nThis is particularly useful for integrating with libraries that handle\ninternationalization or localization, such as:\n\n* Gettext - Set language for translations\n* Fluent - Set language for translations\n* Cldr - Set locale for the Cldr suite\n\n> #### In combination with... {: .neutral}\n> This extension dispatches functions with values from `Routex.Attrs` during\n> runtime. These attributes are typically set by other extensions such as:\n>\n> * `Routex.Extension.Alternatives` (compile time)\n> * `Routex.Extension.Localize.Phoenix` (compile time and runtime)\n> * `Routex.Extension.Localize.Phoenix.Routes` (compile time)\n> * `Routex.Extension.Localize.Phoenix.Runtime` (runtime)","ref":"Routex.Extension.RuntimeDispatcher.html"},{"type":"module","title":"Options - Routex.Extension.RuntimeDispatcher","doc":"* `dispatch_targets` - A list of `{module, function, arguments}` tuples. Any argument\n  that is a list starting with `:attrs` is transformed into `get_in(attrs(), rest)`.\n  Defaults to `[{Gettext, :put_locale, [[:attrs, :runtime, :language]]}]` for zero-config\n  integration with a default Phoenix app.","ref":"Routex.Extension.RuntimeDispatcher.html#module-options"},{"type":"module","title":"Example Configuration - Routex.Extension.RuntimeDispatcher","doc":"````elixir\ndefmodule MyApp.RoutexBackend do\n  use Routex.Backend,\n    extensions: [\n      Routex.Extension.Attrs,\n      Routex.Extension.RuntimeDispatcher\n    ],\n    dispatch_targets: [\n      # Dispatch Gettext locale from detected :language attribute\n      {Gettext, :put_locale, [[:attrs, :runtime, :language]]},\n\n      # Dispatch CLDR locale from detected :locale attribute\n      {Cldr, :put_locale, [MyApp.Cldr, [:attrs, :runtime, :locale]]}\n    ]\nend\n````","ref":"Routex.Extension.RuntimeDispatcher.html#module-example-configuration"},{"type":"module","title":"Error Handling - Routex.Extension.RuntimeDispatcher","doc":"The extension validates all dispatch configurations during compilation to\nensure the specified modules and functions exist:\n\n* Checks if the module is loaded\n* Verifies the function exists with the correct arity\n* Raises a compile-time error if validation fails\n\nExample error:\n\n````elixir\n** (RuntimeError) Gettext does not provide put_locale/1.\n Please check the value of :dispatch_targets in the Routex backend module\n````\n\n## `Routex.Attrs`\n**Requires**\n- none\n\n**Sets**\n- none","ref":"Routex.Extension.RuntimeDispatcher.html#module-error-handling"},{"type":"module","title":"Helpers - Routex.Extension.RuntimeDispatcher","doc":"`dispatch_targets(attrs :: T.attrs) :: :ok`","ref":"Routex.Extension.RuntimeDispatcher.html#module-helpers"},{"type":"function","title":"Routex.Extension.RuntimeDispatcher.call/2","doc":"A plug fetching the attributes from the connection and calling helper function `dispatch_targets/1`","ref":"Routex.Extension.RuntimeDispatcher.html#call/2"},{"type":"function","title":"Routex.Extension.RuntimeDispatcher.handle_params/3","doc":"A Phoenix Lifecycle Hook fetching the attributes from the socket and calling helper function `dispatch_targets/1`","ref":"Routex.Extension.RuntimeDispatcher.html#handle_params/3"},{"type":"module","title":"Routex.Extension.Translations","doc":"Enables users to enter URLs using localized terms which can enhance user engagement\nand content relevance.\n\nExtracts segments of a routes' path to a translations domain file (default: `routes.po`)\nfor translation. At compile-time it combines the translated segments to transform routes.\n\nThis extension expects either a `:language` attribute or a `:locale` attribute. When only\n`:locale` is provided it will try to extract the language from the locale tag. This algorithm\ncovers Alpha-2 and Alpha-3 codes (see:\n[ISO](https://datatracker.ietf.org/doc/html/rfc5646#section-2.2.1))\n\nThis extension requires Gettext >= 0.26.\n\n> #### In combination with... {: .neutral}\n> How to combine this extension for localization is written in de [Localization Guide](guides/LOCALIZE_PHOENIX.md)","ref":"Routex.Extension.Translations.html"},{"type":"module","title":"Configuration - Routex.Extension.Translations","doc":"```diff\ndefmodule ExampleWeb.RoutexBackend do\nuse Routex.Backend,\nextensions: [\n  Routex.Extension.AttrGetters, # required\n+ Routex.Extension.Translations\n]\n+ translations_backend: MyApp.Gettext,\n+ translations_domain: \"routes\",\n```","ref":"Routex.Extension.Translations.html#module-configuration"},{"type":"module","title":"Pseudo result - Routex.Extension.Translations","doc":"# when translated to Spanish in the .po file\n    # - products: producto\n    # - edit: editar\n\n    /products/:id/edit  ⇒ /producto/:id/editar\n\n## `Routex.Attrs`\n**Requires**\n- language || locale\n\n**Sets**\n- none","ref":"Routex.Extension.Translations.html#module-pseudo-result"},{"type":"module","title":"Use case(s) - Routex.Extension.Translations","doc":"This extension can be combined with `Routex.Extension.Alternatives` to create\nmultilingual routes.\n\nUse Alternatives to create new branches and provide a `:language` or `:locale` per branch and\nTranslations to translate the alternative routes.\n\n                        ⇒ /products/:id/edit                  language: \"en\"\n    /products/:id/edit  ⇒ /nederland/producten/:id/bewerken   language: \"nl\"\n                        ⇒ /espana/producto/:id/editar         language: \"es\"","ref":"Routex.Extension.Translations.html#module-use-case-s"},{"type":"module","title":"Routex.Extension.VerifiedRoutes","doc":"Supports the use of original route paths in controllers and templates while rendering\ntransformed route paths at runtime without performance impact.\n\n> #### Implementation summary {:.info}\n> Each sigil and function eventualy delegates to the official\n> `Phoenix.VerifiedRoutes`.  If a non-branching route is provided it will\n> simply delegate to the official Phoenix function. If a branching route is\n> provided, it will use a branching mechanism before delegating.\n\n#### Alternative Verified Route sigil\nProvides a sigil (default: `~l`) to verify transformed and/or branching routes.\nThe sigil to use can be set to `~p` to override the default of Phoenix as\nit is a drop-in replacement. If you choose to override the default Phoenix sigil,\nit is renamed (default: `~o`) and can be used when unaltered behavior is required.\n\n#### Variants of url/{2,3,4} and path/{2,3}\nProvides branching variants of (and delegates to) macro's provided by\n`Phoenix.VerifiedRoutes`. Both new macro's detect whether branching should be\napplied.","ref":"Routex.Extension.VerifiedRoutes.html"},{"type":"module","title":"Options - Routex.Extension.VerifiedRoutes","doc":"- `verified_sigil_routex`: Sigil to use for Routex verified routes (default `\"~l\"`)\n- `verified_sigil_phoenix`: Replacement for the native (original) sigil when `verified_sigil_routex`\n  is set to \"~p\". (default: `\"~o\"`)\n - `verified_url_routex`: Function name to use for Routex verified routes powered `url`. (default: `:rtx_url`)\n- `verified_url_phoenix`: Replacement for the native `url` function when `verified_url_routex`\n  is set to `:url`. (default: `:phx_url`)\n - `verified_path_routex`: Function name to use for Routex verified routes powered `path` (default `:rtx_path`)\n- `verified_path_phoenix`: Replacement for the native `path` function  when `verified_path_routex`\n  is set to `:path`. (default: `:phx_path`)\n\nWhen `verified_sigil_routex` is set to \"~p\" an additional change must be made.\n\n```diff\n# file /lib/example_web.ex\ndefp routex_helpers do\n+  import Phoenix.VerifiedRoutes,\n+      except: [sigil_p: 2, url: 1, url: 2, url: 3, path: 2, path: 3]\n\n    import unquote(__MODULE__).Router.RoutexHelpers, only: :macros\n    alias unquote(__MODULE__).Router.RoutexHelpers, as: Routes\nend\n```","ref":"Routex.Extension.VerifiedRoutes.html#module-options"},{"type":"module","title":"Troubleshoot - Routex.Extension.VerifiedRoutes","doc":"#### Warning about unknown branch\nThe [Verified Routes extension](docs/EXTENSIONS.md#verified-routes) relies on\nthe availability of the `@url` assignment or the key `:rtx_branch`put\nin the process dictionary.\n\nRoutex assigns `@url` automatically in `conn` and `socket`, but you need to explicitly\npass it down to components using Verified Routes (example: ` `)\n\nWhen using a component, make sure :url is a required attribute.\n\n```\nattr :url, :string,\n  required: true,\n  doc: \"Required for Routex' Verified Routes: url={@url}\"\n```\n\nAlternatively, if you don’t mind using process state, you can automatically set the\nprocess key with the [Runtime Dispatcher](docs/EXTENSIONS.md#runtime-dispatcher) extension.\n\n```\n+ dispatch_targets: [{Routex.Utils, :process_put_branch, [[:attrs, :__branch__]]}]\n```","ref":"Routex.Extension.VerifiedRoutes.html#module-troubleshoot"},{"type":"module","title":"Configuration - Routex.Extension.VerifiedRoutes","doc":"```diff\n# file /lib/example_web/routex_backend.ex\ndefmodule ExampleWeb.RoutexBackend do\n  use Routex.Backend,\n  extensions: [\n    Routex.Extension.AttrGetters, # required\n    Routex.Extension.Alternatives,\n    [...]\n+   Routex.Extension.VerifiedRoutes\n],\n+ verified_sigil_routex: \"~p\",\n+ verified_sigil_phoenix: \"~o\",\n+ verified_url_routex: :url,\n+ verified_url_phoenix: :url_native,\n+ verified_path_routex: :path,\n+ verified_path_phoenix: :path_native,\n```","ref":"Routex.Extension.VerifiedRoutes.html#module-configuration"},{"type":"module","title":"Pseudo result - Routex.Extension.VerifiedRoutes","doc":"```elixir\n# given Routex behavior is assigned ~l\n# given the default behavior is assigned ~o\n# given the official macro of Phoenix is assigned ~p\n\n# given another extension has transformed the route\n~o\"/products/#{product}\"   ⇒  ~p\"/products/#{products}\"\n~l\"/products/#{product}\"   ⇒  ~p\"/transformed/products/#{product}\"\n\n# given another extension has generated branches / alternative routes\n~o\"/products/#{product}\"  ⇒  ~p\"/products/#{products}\"\n~l\"/products/#{product}\"  ⇒\n        case current_branch do\n          nil     ⇒  ~p\"/products/#{product}\"\n          \"en\"    ⇒  ~p\"/products/en/#{product}\"\n          \"eu_nl\" ⇒  ~p\"/europe/nl/products/#{product}\"\n          \"eu_be\" ⇒  ~p\"/europe/be/products/#{product}\"\n        end\n```\n\n## `Routex.Attrs`\n**Requires**\n- none\n\n**Sets**\n- none","ref":"Routex.Extension.VerifiedRoutes.html#module-pseudo-result"},{"type":"exception","title":"Routex.Extension.Interpolation.NonUniqError","doc":"Raised when a list of routes contains routes with the same path and verb.\n\n```elixir\n[%Route{\n  path: \"/foo\"\n  verb: :get},\n%Route{\n  path: \"/foo\"\n  verb: :post}, # <-- different\n%Route{\n  path: \"/foo\"\n  verb: :get} # <-- duplicate\n]\n```\n\nSolution: use a combination of interpolated attributes that form a unique set.","ref":"Routex.Extension.Interpolation.NonUniqError.html"},{"type":"module","title":"Routex.Extension.Localize.Parser","doc":"Handles parsing of locale strings.\nUses efficient binary pattern matching and follows RFC 5646 BCP 47 language tag format.","ref":"Routex.Extension.Localize.Parser.html"},{"type":"function","title":"Routex.Extension.Localize.Parser.extract_locale_parts/1","doc":"","ref":"Routex.Extension.Localize.Parser.html#extract_locale_parts/1"},{"type":"function","title":"Routex.Extension.Localize.Parser.extract_part/2","doc":"","ref":"Routex.Extension.Localize.Parser.html#extract_part/2"},{"type":"function","title":"Routex.Extension.Localize.Parser.parse_locale/1","doc":"Parses a single locale string into a locale entry.","ref":"Routex.Extension.Localize.Parser.html#parse_locale/1"},{"type":"function","title":"Examples - Routex.Extension.Localize.Parser.parse_locale/1","doc":"iex> parse_locale(\"en-US\")\n    %{language: \"en\", region: \"US\", territory: \"US\", locale: \"en-US\", quality: 1.0}\n\n    iex> parse_locale(\"fra\")\n    %{language: \"fra\", region: nil, territory: nil, locale: \"fra\", quality: 1.0}\n\n    iex> parse_locale(\"\")\n    nil","ref":"Routex.Extension.Localize.Parser.html#parse_locale/1-examples"},{"type":"module","title":"Routex.Extension.Localize.Phoenix.Detect","doc":"Main module for locale detection logic.","ref":"Routex.Extension.Localize.Phoenix.Detect.html"},{"type":"function","title":"Routex.Extension.Localize.Phoenix.Detect.detect_locales/3","doc":"","ref":"Routex.Extension.Localize.Phoenix.Detect.html#detect_locales/3"},{"type":"module","title":"Routex.Extension.Localize.Phoenix.Extractor","doc":"Extracts locale information from various sources. Handles both `Plug.Conn`\nstructs and map inputs.\n\nSupports languages and regions defined in the [IANA Language Subtag\nRegistry](https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry)","ref":"Routex.Extension.Localize.Phoenix.Extractor.html"},{"type":"module","title":"Sources - Routex.Extension.Localize.Phoenix.Extractor","doc":"List of sources to examine for this field.\n\n* `:accept_language` examines the `accept-language` header.\n* `:body` uses `body_params`; useful when using values in API bodies.\n* `:cookie` uses the request cookie(s)\n* `:host` examines the hostname e.g `en.example.com` and `example.nl`. Returns the first match..\n* `:path` uses `path_params` such as `/:locale/products/`\n* `:query` uses `query_params` such as `/products?locale=en-US`\n* `:route` uses the (precompiled) route attributes.\n* `:session` uses the session\n* `:assigns` uses the assigns stored in connection of socket","ref":"Routex.Extension.Localize.Phoenix.Extractor.html#module-sources"},{"type":"module","title":"Params - Routex.Extension.Localize.Phoenix.Extractor","doc":"List of keys in a source to examine. Defaults to the name of the field with\nfallback to `locale`.","ref":"Routex.Extension.Localize.Phoenix.Extractor.html#module-params"},{"type":"function","title":"Routex.Extension.Localize.Phoenix.Extractor.do_extract_from_source/4","doc":"","ref":"Routex.Extension.Localize.Phoenix.Extractor.html#do_extract_from_source/4"},{"type":"function","title":"Routex.Extension.Localize.Phoenix.Extractor.extract_from_source/4","doc":"","ref":"Routex.Extension.Localize.Phoenix.Extractor.html#extract_from_source/4"},{"type":"module","title":"Routex.Extension.Localize.Phoenix.Parser","doc":"Handles parsing of accept-language headers.\nUses efficient binary pattern matching and follows RFC 5646 BCP 47 language tag format.","ref":"Routex.Extension.Localize.Phoenix.Parser.html"},{"type":"function","title":"Routex.Extension.Localize.Phoenix.Parser.parse_accept_language/1","doc":"Parses an accept-language header into a list of locale entries.","ref":"Routex.Extension.Localize.Phoenix.Parser.html#parse_accept_language/1"},{"type":"function","title":"Examples - Routex.Extension.Localize.Phoenix.Parser.parse_accept_language/1","doc":"iex> parse_accept_language(\"en-US,fr-FR;q=0.8\")\n    [\n      %{language: \"en\", region: \"US\", territory: \"US\", locale: \"en-US\", quality: 1.0},\n      %{language: \"fr\", region: \"FR\", territory: \"FR\", locale: \"fr-FR\", quality: 0.8}\n    ]","ref":"Routex.Extension.Localize.Phoenix.Parser.html#parse_accept_language/1-examples"},{"type":"module","title":"Routex.Extension.Localize.Registry","doc":"Pre-generated locale registry shipped with Routex.\nGenerated from IANA Language Subtag Registry.\n\nIt provides validation and  display name lookups.\n\n**Examples:**\n```iex\niex> alias Routex.Extension.Localize.Registry\niex> Registry.language(\"nl-BE\")\n%{descriptions: [\"Dutch\", \"Flemish\"], type: :language}\n\niex> Registry.region(\"nl-BE\")\n%{descriptions: [\"Belgium\"], type: :region}\n\niex> Registry.language?(\"zz\")\nfalse\n\niex> Registry.region?(\"BE\")\ntrue\n```","ref":"Routex.Extension.Localize.Registry.html"},{"type":"function","title":"Routex.Extension.Localize.Registry.cctld?/1","doc":"","ref":"Routex.Extension.Localize.Registry.html#cctld?/1"},{"type":"function","title":"Routex.Extension.Localize.Registry.language/0","doc":"","ref":"Routex.Extension.Localize.Registry.html#language/0"},{"type":"function","title":"Routex.Extension.Localize.Registry.language/2","doc":"","ref":"Routex.Extension.Localize.Registry.html#language/2"},{"type":"function","title":"Routex.Extension.Localize.Registry.language?/1","doc":"","ref":"Routex.Extension.Localize.Registry.html#language?/1"},{"type":"function","title":"Routex.Extension.Localize.Registry.region/0","doc":"","ref":"Routex.Extension.Localize.Registry.html#region/0"},{"type":"function","title":"Routex.Extension.Localize.Registry.region/2","doc":"","ref":"Routex.Extension.Localize.Registry.html#region/2"},{"type":"function","title":"Routex.Extension.Localize.Registry.region?/1","doc":"","ref":"Routex.Extension.Localize.Registry.html#region?/1"},{"type":"module","title":"Routex.Extension.Localize.Types","doc":"Type definitions for locale detection.","ref":"Routex.Extension.Localize.Types.html"},{"type":"type","title":"Routex.Extension.Localize.Types.locale_entry/0","doc":"","ref":"Routex.Extension.Localize.Types.html#t:locale_entry/0"},{"type":"type","title":"Routex.Extension.Localize.Types.locale_key/0","doc":"","ref":"Routex.Extension.Localize.Types.html#t:locale_key/0"},{"type":"type","title":"Routex.Extension.Localize.Types.locale_result/0","doc":"","ref":"Routex.Extension.Localize.Types.html#t:locale_result/0"},{"type":"type","title":"Routex.Extension.Localize.Types.source/0","doc":"","ref":"Routex.Extension.Localize.Types.html#t:source/0"},{"type":"module","title":"Routex.Extension.Alternatives.Branch.Flat","doc":"Struct for flattened branch","ref":"Routex.Extension.Alternatives.Branch.Flat.html"},{"type":"type","title":"Routex.Extension.Alternatives.Branch.Flat.t/0","doc":"","ref":"Routex.Extension.Alternatives.Branch.Flat.html#t:t/0"},{"type":"module","title":"Routex.Extension.Alternatives.Branch.Nested","doc":"Struct for branch with optionally nested branches","ref":"Routex.Extension.Alternatives.Branch.Nested.html"},{"type":"type","title":"Routex.Extension.Alternatives.Branch.Nested.t/0","doc":"","ref":"Routex.Extension.Alternatives.Branch.Nested.html#t:t/0"},{"type":"module","title":"Routex.Extension.Alternatives.Config","doc":"Module to create and validate a Config struct","ref":"Routex.Extension.Alternatives.Config.html"},{"type":"type","title":"Routex.Extension.Alternatives.Config.t/0","doc":"","ref":"Routex.Extension.Alternatives.Config.html#t:t/0"},{"type":"exception","title":"Routex.Extension.Alternatives.Exceptions.AttrsMismatchError","doc":"Raised when the custom attributes of branches do not have the same keys.\n\n```elixir\n%{\n  branches: %{\n    \"/\"      => %{attrs: %{key1: 1, key2: 2}},\n    \"/other\" => %{attrs: %{key1: 1}} # missing :key2\n  }\n}\n```\n\nTo fix this, make the attribute maps consistent or use an attributes struct.","ref":"Routex.Extension.Alternatives.Exceptions.AttrsMismatchError.html"},{"type":"exception","title":"Routex.Extension.Alternatives.Exceptions.MissingRootSlugError","doc":"Raised when the branch map does not start with the root branch \"/\".\n\n```elixir\n%{\n  branches: %{\n    \"/first\"  =>    %{attrs: %{key1: 1}},\n    \"/other\"  =>    %{attrs: %{key1: 1}}},\n}\n```\n\nTo fix this, include a branch for the root \"/\".\n\n```elixir\n`%{\n  branches: %{\n    \"/\" => %{\n      attrs: %{level: 1}\n      branches: %{\n        \"/first\"  =>    %{attrs: %{level: 2}},\n        \"/other\"  =>    %{attrs: %{level: 2}}\n      }\n    },\n  }\n}\n```","ref":"Routex.Extension.Alternatives.Exceptions.MissingRootSlugError.html"},{"type":"extras","title":"Overview","doc":"# \n![Logo of Routex](assets/logo_horizontal.png \"Routex Logo\")\n\n![Coveralls](https://img.shields.io/coveralls/github/BartOtten/routex)\n[![Build Status](https://github.com/BartOtten/routex/actions/workflows/elixir.yml/badge.svg?event=push)](https://github.com/BartOtten/routex/actions/workflows/elixir.yml)\n[![Last Updated](https://img.shields.io/github/last-commit/BartOtten/routex.svg)](https://github.com/BartOtten/routex/commits/main)\n[![Hex.pm](https://img.shields.io/hexpm/v/routex)](https://hex.pm/packages/routex)\n![Hex.pm](https://img.shields.io/hexpm/l/routex)\n\n# Routex: Phoenix route localization and beyond....\n\nRoutex is a comprehensive, batteries included framework built on top of Phoenix,\ndesigned to streamline and empower your routing workflows. By simplifying route\nmanipulation at compile time and enabling the use of custom route attributes\nduring runtime, Routex provides the granular control needed to tackle the most\ncomplex routing challenges.\n\nIts modern, extensible architecture allows for effortless creation of custom\nsolutions, extending its functionality far beyond standard routing.","ref":"readme.html"},{"type":"extras","title":"Localize Phoenix - Overview","doc":"For developers seeking robust Phoenix localization solutions, Routex excels. It\noffers a suite of extensions enabling internationalization (i18n) and\nlocalization (l10n), including but not limited to seamless support for\ntranslated (multilingual) URLs, locale preference detection at run time and\nsupport for multiple backends.\n\nThe included extension `Localize Phoenix` simplifies Phoenix localization by\ndetecting already used localization packages (Cldr, Gettext or Fluent) and\nautomatically generate routes based on their existing configuration for a\nseamless experience or using your manual configuration for powerful\ncustomization.\n\nThe extension includes an `IANA` based locale registry\nfor robust locale validation and conversion to display names.\n\nForget any notion of difficult setup – localizing your Phoenix application with\nRoutex is a breeze. Just copy the example configuration from our [Localize\nPhoenix using Routex guide](docs/guides/LOCALIZE_PHOENIX.md) for an effortless\nstart.\n\n \nThis documentation reflects the main branch. For the latest\nstable release, refer to  HexDocs ).","ref":"readme.html#localize-phoenix"},{"type":"extras","title":"Benefits and Features: - Overview","doc":"* **Simplify development:** Routex combines compile-time code generation with\n  dynamic runtime behavior by seamlessly integrating LiveView lifecycle hooks\n  and pipeline Plugs. This enables extensions to provide powerful runtime\n  features such as automatically locale detection and synchronization between\n  the server, client, and LiveView processes- without requiring modifications\n  throughout your codebase.\n\n* **Drop-in solution:** Extensions are highly configurable, allowing you to use\n  Routex features as drop-in solution. For example: Routex can be configured to\n  remain compatible with Phoenix' template generators. As such, it doesn't\n  disrupt standard Phoenix development practices lowering the learning curve. It\n  can also be configured to mimic Cldr-Routes with its tight integration wirth\n  Cldr and use of custom sigils.\n\n* **Optimized Performance:** Positioned between route configuration and\n  compilation, Routex core enhances Phoenix routes without incurring additional\n  runtime costs. Extensions too are optimized for runtime performance, making\n  use of Elixirs superb pattern matching.\n\n* **No dependencies, no state**: Routex is unique in not depending on other\n  libraries and works out-of-the-box without process state. An extension to\n  control third-party libraries that do rely on state such as Gettext is\n  included.\n\n* **Detailed documentation**: Comprehensive, well-organized documentation\n  provides clear guidance on installation, configuration, and best practices,\n  making Routex approachable for developers at all levels.","ref":"readme.html#benefits-and-features"},{"type":"extras","title":"Give it a try! - Overview","doc":"**[Online demo](https://routex.fly.dev/)** - have a look or get the\n[code](https://github.com/BartOtten/routex_example/).","ref":"readme.html#give-it-a-try"},{"type":"extras","title":"Installation and usage - Overview","doc":"**[Usage Guide](USAGE.md)** - requirements and installation.\ninstructions.\n\n**[Documentation](https://hexdocs.pm/routex)** - from step-by-step guides till in-depth explanations.","ref":"readme.html#installation-and-usage"},{"type":"extras","title":"Knowledge Base - Overview","doc":"To better understand how Routex integrates with Phoenix Router and where it fits\ninto the broader ecosystem, take a look at our in-depth guides:\n\n**[How Routex and Phoenix Router Work Together](docs/ROUTEX_AND_PHOENIX_ROUTER.md)** - \nDiscover the mechanics behind the integration and the benefits of a unified routing system.\n\n**[Routex compared to Phoenix Router and Cldr Routes](docs/COMPARISON.md)** - \nUnderstand the differences, strengths, and tradeoffs when deciding which\nrouting solution best fits your needs.","ref":"readme.html#knowledge-base"},{"type":"extras","title":"Extensions - Overview","doc":"Routex comes equipped with a extensions that cater to common and advanced use\ncases in Phoenix applications. Each extension is designed to operate\nindependently yet harmoniously with other extensions through the shared\n`Routex.Attrs` system. This flexibility allows you to tailor your routing system\nto your specific needs without resorting to extensive modifications or the\nburden of maintaining a fork.","ref":"readme.html#extensions"},{"type":"extras","title":"Benefits: - Overview","doc":"- **Modularity**: Each feature is encapsulated in its own extension, making\n  it easier to manage and maintain.\n- **Flexibility**: Extensions can be enabled or disabled as needed, allowing\n  for a customizable and adaptable routing system.\n- **Interoperability**: By using `Routex.Attrs` to share attributes, extensions\n  can work together seamlessly without being tightly coupled, promoting a\n  decoupled and scalable architecture.\n- **Customizability**: If you have a unique requirement, you can adapt an\n  existing extension -or create your own- without the need to fork or reach\n  upstream consensus on the need and purpose.","ref":"readme.html#benefits"},{"type":"extras","title":"Index - Overview","doc":"#### Specialized suites\n- [Localize Phoenix](docs/EXTENSIONS.md#localize-phoenix): Simple localization of Phoenix using auto-detection of \n  localization libs. Combines [Localize Phoenix Routes](docs/EXTENSIONS.md#localize-phoenix-routes) and\n  [Localize Phoenix Runtime](docs/EXTENSIONS.md#localize-phoenix-runtime).\n\n#### Adapters for third-parties\n- [Cldr Adapter](docs/EXTENSIONS.md#cldr-adapter): tight integration with `:ex_cldr` (mimics `cldr-routes` and `cldr-plugs`).\n\n#### Phoenix shims\n- [Verified Routes](docs/EXTENSIONS.md#verified-routes): (Locale) Branch aware variant of Phoenix.VerifiedRoutes.\n- [Route Helpers](docs/EXTENSIONS.md#route-helpers): (Locale) Branch aware Phoenix Helpers.\n\n#### Feature extensions\n- [Alternatives](docs/EXTENSIONS.md#alternatives): Create (nested) alternative routes.\n- [Alternative Getters](docs/EXTENSIONS.md#alternative-getters): List all alternative routes for the current route.\n- [Assigns](docs/EXTENSIONS.md#assigns): Use route attributes as assigns in templates (e.g. `@custom_attribute`).\n- [Attribute Getters](docs/EXTENSIONS.md#attribute-getters): Fetch all custom attributes of any route.\n- [Interpolation](docs/EXTENSIONS.md#interpolation): Use route attributes in route definitions at any place (e.g. `live /page/products/#{language}/:id`.\n- [LiveView Hooks](docs/EXTENSIONS.md#liveview-hooks): Integrate LiveView Lifecycle hooks provided by other extensions.\n- [Localize Phoenix Routes](docs/EXTENSIONS.md#localize-phoenix-routes): Localize Phoenix routes with the help of an [IANA](https://www.iana.org/) based locale registry).\n- [Localize Phoenix Runtime](docs/EXTENSIONS.md#localize-phoenix-runtime): Highly configurable locale detection using multiple sources (StaticView and LiveView).\n- [Plugs](docs/EXTENSIONS.md#plugs): Integrate plugs provided by other extensions.\n- [Runtime Dispatcher](docs/EXTENSIONS.md#runtime-dispatcher): Dispatch to arbitrary functions at runtime using route attributes as arguments.\n- [Translations](docs/EXTENSIONS.md#translations): Translate route segments / full localized URLs.\n\n#### Showcases\n- [Cloak](docs/EXTENSIONS.md#cloak-showcase):  Demonstrates Routex' support for extreme route transformations.","ref":"readme.html#index"},{"type":"extras","title":"Development - Overview","doc":"Contributions to Routex are highly appreciated! Whether it's a simple typo fix,\na new extension or any other improvement.\n\nWant to validate your idea? [Use our discussion\nboard](https://github.com/BartOtten/routex/discussions)\n\n- **clone Routex: https://github.com/BartOtten/routex**  \n  The main branch is the active development branch.\n\n- **clone Routex Example app: https://github.com/BartOtten/routex_example**  \n  Use either the main branch or watch for branches indicating a newer version\n\n- **copy or symlink `routex` into `routex_example`**  \n  This causes the example to use the locale routex\n\n- **enable AST insight in the example app**  \n  Inspecting the helpers generated by Routex' extensions helps a lot\n\n  ```elixir\n  # In routex_example/config/dev.ex\n  config :routex, helper_mod_dir: \"/tmp\"\n  ```","ref":"readme.html#development"},{"type":"extras","title":"Included extensions","doc":"# Routex Extensions\n\nRoutex includes a variety of extensions to cover the most common use cases in\nPhoenix applications. Each extension provides a single feature and has no hard\ndependencies on other extensions. Instead, extensions make use of Routex.Attrs\nto share attributes; allowing extensions to work together without being coupled.\n\n**Benefits**:\n- **Modularity**: Each feature is encapsulated in its own extension, making\n  it easier to manage and maintain.\n- **Flexibility**: Extensions can be enabled or disabled as needed, allowing\n  for a customizable and adaptable routing system.\n- **Interoperability**: By using `Routex.Attrs` to share attributes, extensions\n  can work together seamlessly without being tightly coupled, promoting a\n  decoupled and scalable architecture.\n- **Customizability**: If you have a rare requirement, you can adapt an existing\n  extension or provide your own, without need for a fork or upstream support.","ref":"extensions.html"},{"type":"extras","title":"Index - Included extensions","doc":"- [Localize Phoenix](#localize-phoenix): A streamlined solution for localizing Phoenix routes with minimal setup.\n- [Localize Phoenix Routes](#localize-phoenix-routes): Generate localized routes at compile time.\n- [Localize Phoenix Runtime](#localize-phoenix-runtime): Plug and play locale detection (StaticView and LiveView).\n- [Alternatives](#alternatives): Create (nested) alternative routes.\n- [Alternative Getters](#alternative-getters): Get alternatives for the current route.\n- [Verified Routes](#verified-routes): Branch aware variant of Phoenix.VerifiedRoutes.\n- [Assigns](#assigns): Use route attributes as assigns in templates.\n- [Interpolation](#interpolation): Use attributes in route definitions.\n- [Translations](#translations): Translate route segments / full localized URLs.\n- [Attribute Getters](#attribute-getters): Retrieve `Routex.Attrs` for a route.\n- [Cldr Adapter](#cldr-adapter): Use an existing `:ex_cldr`configuration.\n- [Plugs](#plugs): Integrate plugs provided by extensions.\n- [LiveView Hooks](#liveview-hooks): Attach LiveView Lifecycle hooks provided by extensions.\n- [Route Helpers](#route-helpers): Create branch aware Phoenix Helpers.\n- [Cloak](#cloak-showcase): Showcase to demonsrate extreme route transformations.\n- [Runtime Dispatcher](#runtime-dispatcher): Dispatch to arbitrary functions using route attributes as argument.","ref":"extensions.html#index"},{"type":"extras","title":"Localize Phoenix - Included extensions","doc":"**Feature**: A streamlined solution for localizing Phoenix routes with minimal setup.\n\n[Localize Phoenix Documentation](https://hexdocs.pm/routex/Routex.Extension.Localize.Phoenix.html)","ref":"extensions.html#localize-phoenix"},{"type":"extras","title":"Localize Phoenix Runtime - Included extensions","doc":"**Feature**: Plug and play locale detection in StaticViews and LiveViews.\n\n**Benefits**: Being highly customizable this locale detection adapts to your project instead of the other way around.\n\n**Example**: Set the `locale` attribute based on the [HTTP accept-language header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Accept-Language).\n\n```elixir\nlocale_sources: [:query, :session, :accept_language, :route],\nlocale_params: [\"locale\"]\nlanguage_sources: [:query, :route],\nlanguage_params: [\"custom_lang\"]\n```\n\n[Localize Phoenix Runtime Documentation](https://hexdocs.pm/routex/Routex.Extension.Localize.Phoenix.Runtime.html)","ref":"extensions.html#localize-phoenix-runtime"},{"type":"extras","title":"Localize Phoenix Routes - Included extensions","doc":"**Feature**: Generate localize routes using automatic configuration base on Cldr, Gettext or Fluent (with options to override).\n\n**Benefits**: Improves SEO, content relevance and user convenience\n\n**Example**: Expand routes to multiple (nested) locale routes with custom attributes.\n\n```elixir\nRouter              Generated                         Attributes\n                      ⇒ /products/:id/edit              locale: \"en\", contact: \"rootexample.com\"\n  /products/:id/edit  ⇒ /europe/nl/products/:id/edit    locale: \"nl\", contact: \"verkoop@example.nl\"\n                      ⇒ /europe/be/products/:id/edit    locale: \"nl\", contact: \"handel@example.be\"\n                      ⇒ /gb/products/:id/edit           locale: \"en\", contact: \"sales@example.com\"\n```\n\n[Localize Phoenix Routes Documentation](https://hexdocs.pm/routex/Routex.Extension.Localize.Phoenix.Routes.html)","ref":"extensions.html#localize-phoenix-routes"},{"type":"extras","title":"Runtime Dispatcher - Included extensions","doc":"**Feature**: Dispatch to arbitrary functions using route attributes as argument.\n\n**Benefits**: This is particularly useful for integrating with internationalization libraries like:\n\n  * Gettext - Set language for translations\n  * Fluent - Set language for translations\n  * Cldr - Set locale for the Cldr suite\n\n\n**Example**: Call `Gettext.put_locale/1` using the `locale` attribute set by Localize.Routes or Localize.Runtime.\n\n```elixir\n dispatch_targets: [\n  # Set Gettext locale from :language attribute\n  {Gettext, :put_locale, [[:attrs, :locale]]},\n ]\n```\n\n[Runtime Dispatcher Documentation](https://hexdocs.pm/routex/Routex.Extension.RuntimeDispatcher.html)","ref":"extensions.html#runtime-dispatcher"},{"type":"extras","title":"Alternatives - Included extensions","doc":"**Feature**: Create alternative routes based on `branches` configured in a\nRoutex backend module. Branches can be nested, and each branch can provide its\nown attributes to share with other extensions.\n\n**Benefits**: Enables the definition of alternative routing paths and\ntheir attributes in a single place.\n\n**Example**: You can configure different branches for different locales or\nversions of your application, providing users with the appropriate routes\nbased on their context.\n\n[Alternatives Documentation](https://hexdocs.pm/routex/Routex.Extension.Alternatives.html)","ref":"extensions.html#alternatives"},{"type":"extras","title":"Alternative Getters - Included extensions","doc":"**Feature**: Creates a helper function `alternatives/1` to get a list of\nalternative slugs and their route attributes. Includes the current route with\n`match?: true` attribute.\n\n**Benefits**: Simplifies the retrieval and use of alternative routes for the\ncurrent page.\n\n**Example**: Easily display navigation buttons for alternative routes with\nhighlighting of the current active route.\n\n```heex\n<.link\n   :for={alternative <- alternatives(@url)}\n   navigate={alternative.slug}\n >\n   <.button class={alternative.match? && \"active\" || \"inactive\"}>\n     <%= alternative.attrs.display_name %>\n   </.button>\n </.link>\n ```\n\n[Alternative Getters Documentation](https://hexdocs.pm/routex/Routex.Extension.AlternativeGetters.html)","ref":"extensions.html#alternative-getters"},{"type":"extras","title":"Verified Routes - Included extensions","doc":"**Feature**: Creates a sigil (default: `~l`) that renders a link based on the\ncurrent branch of a user and verifies routes even when transformed by Routex\nextensions. Can be set to `~p` to act as a drop-in replacement for the official\nPhoenix sigils.\n\nAlso provides branch-aware variants of `url/{2,3,4}` and `path/{2,3}`.\n\n**Benefits**: Ensures route integrity and security while supporting dynamic\nroute transformations.\n\n**Example**: Use the `~p` sigil to generate URLs that adapt to the user's\ncurrent context or locale, ensuring they are always valid.\n\n```elixir\n# given Routex behavior is configured as drop-in replacement using ~p\n# giving original ~p is reassigned to ~o\n# given another extension has generated branches / alternative routes\n\n~o\"/products/#{product}\"  ⇒  Phoenix.sigil_p(\"/products/#{products}\")\n~p\"/products/#{product}\"  ⇒\n        case current_branch do\n          nil     ⇒  Phoenix.sigil_p(\"/products/#{product}\")\n          \"fr\"    ⇒  Phoenix.sigil_p(\"/produits/#{product}\")\n          \"es\"    ⇒  Phoenix.sigil_p(\"/productos/#{product}\")\n        end\n```\n\n[Verified Routes Documentation](https://hexdocs.pm/routex/Routex.Extension.VerifiedRoutes.html)","ref":"extensions.html#verified-routes"},{"type":"extras","title":"Assigns - Included extensions","doc":"**Feature**: Adds attributes set by other extensions to Phoenix assigns,\nmaking them available in components and controllers.\n\n**Benefits**: Provides easy access to route-specific attributes within the\napplication's components and controllers.\n\n**Example**: Access route attributes like `@namespace.area` or\n`@namespace.contact` directly in your templates.\n\n```elixir\n     @namespace.area      =>  :eu_nl\n     @namespace.contact   =>  \"contact@example.com\"\n```\n\n[Assigns Documentation](https://hexdocs.pm/routex/Routex.Extension.Assigns.html)","ref":"extensions.html#assigns"},{"type":"extras","title":"Interpolation - Included extensions","doc":"**Feature**: Allows -any- attribute assigned to a route to be used at -any-\nplace for route interpolation, especially effective with extensions like\n`Alternatives`.\n\n**Benefits**: Provides dynamic and customizable URL patterns based on various\nattributes.\n\n**Example**: Generate URLs like `/europe/products/nl/:id` where `territory` and\n`language` are dynamically interpolated.\n\n```elixir\n    /#{territory/products/#{language}/:id  => /europe/products/nl/:id\n```\n\n[Interpolation Documentation](https://hexdocs.pm/routex/Routex.Extension.Interpolation.html)","ref":"extensions.html#interpolation"},{"type":"extras","title":"Translations - Included extensions","doc":"**Feature**: Extracts segments of a route's path to a `routes.po` file for\ntranslation. At compile-time, it combines the translated segments to translate\nroutes, allowing users to enter URLs using localized terms.\n\n**Benefits**: Enhances user engagement and content relevance by supporting\nlocalized URLs.\n\n**Example**: Users can visit your website using URLs in their own language,\nsuch as `/productos` instead of `/products` for Spanish-speaking users.\n\n[Translations Documentation](https://hexdocs.pm/routex/Routex.Extension.Translations.html)","ref":"extensions.html#translations"},{"type":"extras","title":"Attribute Getters - Included extensions","doc":"**Feature**: Creates a helper function `attrs/1` to get all `Routex.Attrs` of a\nroute.\n\n**Benefits**: Allows conditional access to route attributes without affecting\nperformance.\n\n**Example**: Retrieve all attributes for the current page with `attrs(@url)`.\n\n[Attribute Getters Documentation](https://hexdocs.pm/routex/Routex.Extension.AttrGetters.html)","ref":"extensions.html#attribute-getters"},{"type":"extras","title":"Cldr Adapter - Included extensions","doc":"**Feature**: Provides integration for projects using `:ex_cldr`.\n\n**Benefits**: Seamlessly integrates Routex with `:ex_cldr`.\n\n**Example**: Utilize CLDR's localization features within your routing logic.\n\n[Cldr Adapter Documentation](https://hexdocs.pm/routex/Routex.Extension.Cldr.html)","ref":"extensions.html#cldr-adapter"},{"type":"extras","title":"Plugs - Included extensions","doc":"**Feature**: Detects and registers supported plug callbacks from other\nextensions, encapsulating them in a single plug chain.\n\n**Benefits**: Integrates extension plugs seamlessly, ensuring they are invoked\nin order during the plug pipeline.\n\n**Example**: Provides a unified plug that incorporates functionality from\nmultiple extensions, simplifying plug management.","ref":"extensions.html#plugs"},{"type":"extras","title":"LiveView Hooks - Included extensions","doc":"**Feature**: Attaches LiveView hooks provided by Routex extensions, injecting\nthem into LiveView's lifecycle stages.\n\n**Benefits**: Enables extensions to provide hooks for LiveView components,\nenhancing their functionality and integration.\n\n**Example**: Automatically invoke extension hooks during LiveView lifecycle\nevents like `handle_params`, `handle_event`, and `handle_info`.","ref":"extensions.html#liveview-hooks"},{"type":"extras","title":"Route Helpers - Included extensions","doc":"**Feature**: Creates branch aware Phoenix Helpers. Can replace the original\nPhoenix Route Helpers as drop-ins.\n\n**Benefits**: Simplifies route handling and branching within Phoenix\napplications.\n\n**Example**: Use these helpers to generate URLs that adapt to the user's current\ncontext or locale.\n\n[Route Helpers Documentation](https://hexdocs.pm/routex/Routex.Extension.RouteHelpers.html)","ref":"extensions.html#route-helpers"},{"type":"extras","title":"Cloak (showcase) - Included extensions","doc":"**Feature**: Transforms routes to be unrecognizable, demonstrating the\nflexibility of Routex.\n\n**Benefits**: Offers a way to obscure URL patterns for added security or\nexperimentation.\n\n**Example**: Converts `/products/:id/edit` to `/:id/02`.\n\n```elixir\n Original                 Rewritten     Result (product_id: 88, 89, 90)\n /products                =>     /01     =>    /01\n /products/:id/edit       => /:id/02     => /88/02, /89/02, /90/02 etc...\n /products/:id/show/edit  => /:id/03     => /88/03, /89/03, /90/03 etc...\n```\n\n[Cloak Documentation](https://hexdocs.pm/routex/Routex.Extension.Cloak.html)","ref":"extensions.html#cloak-showcase"},{"type":"extras","title":"Release Notes","doc":"# Announcing Routex 1.2.0 – Effortless Phoenix Localization\n\nI’m thrilled to announce **Routex 1.2.0**, a major update that brings\nzero‑config internationalization (i18n) and and localization (l10n) to your\nPhoenix apps. It plugs straight into Cldr, Gettext, or Fluent and eliminates the\nboilerplate of manual locale plugs and translation hooks.\n\n** Summary **\n- Simplified localization\n- Comprehensive runtime integration\n- Enhanced developer tools\n- Community-driven improvements","ref":"release_notes.html"},{"type":"extras","title":"1. Zero-Config Localization with Multilingual Routing - Release Notes","doc":"Building multilingual Phoenix sites used to mean scattering locale detection,\nLiveView hooks, and dynamic-route logic throughout your code. **Routex 1.2.0**\nreplaces all that with a single, centralized configuration. Your router stays\nclean, localization is applied at compile time, and runtime dispatching\nseamlessly handles any additional needs—no extra wiring required.\n\nThe new Localization system is a game-changer automatically detecting your\nexisting Phoenix localization setup and making everything work out of the box.\nLet's see this magic in action with a typical Phoenix application:\n\n```elixir\n# lib/my_app_web/routex_backend.ex\ndefmodule ExampleWeb.RoutexBackend do\n    use Routex.Backend,\n      extensions: [\n        Routex.Extension.Attrs,\n        Routex.Extension.LiveViewHooks,\n        Routex.Extension.Plugs,\n        Routex.Extension.Localize.Phoenix.Routes,\n        Routex.Extension.Localize.Phoenix.Runtime,\n        Routex.Extension.RuntimeDispatcher\n      ]\n```\n\nUsing the sane defaults of the extensions Routex will transforms your routes\nbased on your Gettext locales (or Cldr, or Fluent). For example, if your Gettext has \"en\" (default),\n\"fr\", and \"nl\" configured, Routex automatically generates:\n\n```elixir\n# Example: Generated Routes\n# Original route: /products\n\"/products\"          # Default locale (en)\n\"/fr/products\"       # French\n\"/nl/products\"       # Dutch\n```\n\nThe magic continues at runtime. Routex automatically:\n1. Detects the user's preferred language from a variary of sources\n2. Sets up Gettext with the correct locale\n3. Maintains the locale across LiveView navigation\n4. Provides helper functions for switching locales\n\nWant to customize? No problem! The zero-config setup can be enhanced with\nexplicit configuration. Here are a few examples:\n\n```elixir\n# lib/my_app_web/routex_backend.ex\n\n# Override auto-detected locale settings for route generation\nlocales: [\"en-US\", \"fr-FR\", \"nl-BE\": %{language_display_name: \"DUTCH\"}}],\ndefault_locale: \"en-US\",\n\n# Customize URL generation: results in /english, /french, /dutch\nlocale_prefix_sources: [:language_display_name],\n\n# Customize URL generation: results in \"/\", \"/world\", \"/france\", \"/netherlands\", \"/belgium\"\nlocale_prefix_sources: :region_display_name\n\n# Customize region detection order: fixed to route attribute, no overrides\nregion_sources: [:route],\n\n# Customize language detection order\nlanguage_sources: [:query, :session, :accept_language, :route]\n```\n\nThe Localize extensions come with a IANA Language Subtags based locale registry\ncovering common needs. The `language/1` and `region/1` functions can be used to\ntranslate locale, region and language identifiers to display names. `language?`\nand `region?` validate input.\n\n```elixir\n# single subtag\niex> Routex.Extension.Localize.Registry.region(\"BE\")\n%{descriptions: [\"Belgium\"], type: :region}\n\n# double subtag\niex> Routex.Extension.Localize.Registry.language(\"nl-BE\")\n%{descriptions: [\"Dutch\", \"Flemish\"], type: :language}\n```","ref":"release_notes.html#1-zero-config-localization-with-multilingual-routing"},{"type":"extras","title":"2. Enhanced integration with other libraries - Release Notes","doc":"For scenarios requiring integration with other third-party libs, Routex 1.2.0\nintroduces runtime dispatch targets through the\n`Routex.Extension.RuntimeDispatcher` extension. The dispatch targets are\nautomatically called using a Plug and Liveviews events using a LiveView\nLifecycle Hook.\n\n```elixir\ndispatch_targets: [\n    # Set Gettext locale using detected :language attribute (this is a default)\n    {Gettext, :put_locale, [[:attrs, :runtime, :language]]},\n\n    # Custom dispatch using routes :region attribute\n    {MyModule, :set_region, [[:attrs, :route, :region]]},\n]\n```","ref":"release_notes.html#2-enhanced-integration-with-other-libraries"},{"type":"extras","title":"3. Automated LiveView lifecycle hooks and plugs - Release Notes","doc":"Two new extensions add support for the detection and auto-enabling of Plugs and\nLiveView Livecycle Hooks provided by other extensions. This seamless integration\nimproves the overall developer experience (DX) by reducing the friction of\nadditional plug and hook configuration.\n\n\n```elixir\n# lib/my_app_web/routex_backend.ex\nextensions: [\n  Routex.Extension.LiveViewHooks, #  detects and enables LiveView Lifecycle callbacks\n  Routex.Extension.Plugs,         #  detects and enables Plug calls\n]\n```","ref":"release_notes.html#3-automated-liveview-lifecycle-hooks-and-plugs"},{"type":"extras","title":"4. A Better Development Experience - Release Notes","doc":"We've completely overhauled the development experience.\n\n- Crystal-clear error messages\n- Built-in AST inspection for debugging\n\n\n#### Clearer Error Messages\n\nConfiguration issues now trigger clearer error messages. Instead of encountering\na full stacktrace, you receive concise guidance to help pinpoint and resolve\ncommon mistakes. Such as:\n\n\nRaised during pre-processing when an extension is missing:\n\n```\nExtension 'Routex.Extension.404' not found.\n```\n\nOr when the `attrs/1` helper function is missing:\n\n```\nRoutex Error: Missing required implementation of `attrs/1`.\n\n       None of the enabled extensions provide an implementation for `attrs/1`.\n       Please ensure that you have added and configured an extension that\n       implements this function. For more details on how to set up the\n       AttrGetters extension, see the documentation:\n\n       https://hexdocs.pm/routex/Routex.Extension.AttrGetters.html\n```\n\n\n#### AST Inspection Option\n\nA new configuration setting allows developers to output the generated code for\ninspection. This additional transparency can be valuable for diagnosing issues\nwith the extension-generated helper functions.\n\n```elixir\n# In config/dev.ex\nconfig :routex, helper_mod_dir: \"/tmp\"\n```\n\nDuring compilation, the generated code is saved to your specified directory for review:\n\n```bash\nWrote AST of Elixir.ExampleWeb.Router.RoutexHelpers to /tmp/ExampleWeb.Router.RoutexHelpers.ex\n```\n\nReady to be inspected.\n`cat /tmp/ExampleWeb.Router.RoutexHelpers.ex`\n\n```elixir\ndefmodule ExampleWeb.Router.RoutexHelpers do\n  @moduledoc \"This code is generated by Routex and is for inspection purpose only\\n\"\n\n    require Logger\n    use Routex.HelperFallbacks\n\n    @doc \"Returns Routex attributes of given URL\\n\"\n    def attrs(url) when is_binary(url) do\n        url |> Matchable.new() |> attrs()\n    end\n\n    # ... all other helper functions ...\n```","ref":"release_notes.html#4-a-better-development-experience"},{"type":"extras","title":"5. Improved Reliability and Performance - Release Notes","doc":"","ref":"release_notes.html#5-improved-reliability-and-performance"},{"type":"extras","title":"Faster compilation, faster runtime - Release Notes","doc":"Several improvements have been made to the Routex pre-processing engine for\nbetter compilation. The revamped processing model brings compile‑time\noptimizations, and increases the amount of supported routes to multiple\nhundreds.\n\nBuild-in extensions have been recrafted for reduced generated code and enhanced\nperformance thanks to Elixir’s robust pattern matching and function call\noptimizations -ensuring that your app remain both fast and reliable.\n\nA brief summary of the processed routes is now provided during compilation.\n\n```elixir\nRoutex.Processing >> Routes >> Original: 16 | Generated: 100 | Total: 116\n```","ref":"release_notes.html#faster-compilation-faster-runtime"},{"type":"extras","title":"Improved Reliability - Release Notes","doc":"#### Increased Test Coverage\n\nWith over 90% test coverage, the core functionality and error-handling paths\nhave been thoroughly verified. This improvement helps reduce regressions and\nensures better stability.","ref":"release_notes.html#improved-reliability"},{"type":"extras","title":"Community Contributions - Release Notes","doc":"Welcome to new contributors who have improved the project.\n\nKrister Viirsaar **reported issues** with setup en especially with the Localize\nPhoenix tutorial. The issue is titled \"Localization guide is missing step to\ncontent translation (using Gettext)\". Let's say this lengthy release note is\nRoutex' reply....thanks Krister!\n\nNiels Ganser and Max Gorin for contributing **fixes to the documentation**. Although\nsmall in size, such contributions make impact. Nobody likes broken links or\nincorrect instructions.\n\nA special thanks to Kenneth Kostrešević -you may recognize his name from the Ash\nweekly- as he **spotted and fixed an embarrasing regression** before it was released. His\nextra addition to the test suite ensures the issue won't sneak into the codebase\nagain again.\n\nContributions are highly welcome!","ref":"release_notes.html#community-contributions"},{"type":"extras","title":"Looking Forward - Release Notes","doc":"As we continue to evolve Routex, our focus remains steadfast on making Phoenix\nroute management as effortless as possible. This release marks a significant\nstep toward that goal, with features that not only make development easier but\nalso more enjoyable.\n\nThe next grand release will be focussing on even easier setup. Kenneth Kostrešević\nhas already begon the work to craft a one-command setup using an **Igniter installer**","ref":"release_notes.html#looking-forward"},{"type":"extras","title":"Conclusion - Release Notes","doc":"Routex 1.2.0 sets a new benchmark for Phoenix localization by turning a once\ncumbersome process into a streamlined, configuration‑driven experience. Upgrade\ntoday to harness automated locale detection, dynamic routing enhancements, and\nan unparalleled developer experience that empowers you to build world‑class\nmultilingual Phoenix applications—all while reducing boilerplate and enhancing\nmaintainability.\n\nReady to upgrade? Check out our\n[documentation](https://bartotten.github.io/routex/readme.html) for a smooth\ntransition to the latest version.\n\nHappy coding, and enjoy the future of Phoenix localization with Routex 1.2.0!\n\n\n---","ref":"release_notes.html#conclusion"},{"type":"extras","title":"TLDR not your cup of tea? The Localize Suite in more Detail - Release Notes","doc":"As Routex demands \"Simple by default, powerful when needed\", it broads not one,\nbut two extensions for localization.","ref":"release_notes.html#tldr-not-your-cup-of-tea-the-localize-suite-in-more-detail"},{"type":"extras","title":"1. Localize.Phoenix.Routes - Release Notes","doc":"Localize Phoenix routes using simple configuration.\n\n  At compile time, this extension generates localized routes based on locale\n  tags. These locale tags are automatically derived from your Cldr, Gettext or\n  Fluent setup and can be overriden using the extensions options.\n\n  #### Notable features\n  - **Buildin locale registry**: Locale subtags can be validated and converted to human-friendly display\n  names using the buildin locale registry based on the authoritive\n  [IANA Language Subtag Registry](https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry).\n  - **Automated locale expansion**: At _compile time_ this extension will expand a routes `:locale` attribute into multiple attributes such as \n  `:language` (e.g., \"en\") and `:language_display_name`\n  - **Locale branch attributes (overrides)**\n    Assign or override attributes for a specific locale routes branch.\n     **Example:**\n     ```elixir\n      locales: [\n       # Standard English\n       \"en\",\n       # Standard French\n       \"fr\"\n       # Language: \"English\", Region: \"Global\" displayed as \"Worldwide\"\n       \"en-001\": %{region_display_name: \"Worldwide\"},\n       # Language: \"English\", Region: \"Great Brittain\", Compile time route attributes: %{currency: \"GBP\"}\n       \"en-GB\": %{currency: \"GBP\"},\n     ]\n     ```\n\n     > #### Attribute Merging Precedence (Compile Time, low to high):\n     > 1. Derived from locale string\n     > 2. Explicit Locale Override (from attrs in tuple)\n     > 3. Original Branch Attribute (already existing on the branch)\n     >\n     > Point 3 ensures this extension plays well with\n     > pre-configured alternative branches.\n\n    - **Custom route prefixes**\n     Locale attributes to prefix routes with, supporting the automated expanded locale attributes.\n\n     **Examples:**\n      ```elixir\n      # in configuration\n      locales: [\"en-001\", \"fr\", \"nl-NL\", \"nl-BE\"]\n      default_locale: \"en\"\n\n      # single source\n      locale_prefix_sources: :locale =>     [\"/\", \"/en-001\", \"/fr\", \"/nl/nl\", \"/nl-be\"],\n      locale_prefix_sources: :language => [\"/\", \"/fr\", \"/nl\"],\n      locale_prefix_sources: :region =>     [\"/\", \"/001\", \"/nl\", \"/be\"]\n      locale_prefix_sources: :language_display_name =>     [\"/\", \"/english\", \"/french\", \"/dutch\"]\n      locale_prefix_sources: :region_display_name =>     [\"/\", \"/world\", \"/france\", \"/netherlands\", \"/belgium\"]\n\n      # with fallback\n      locale_prefix_sources: [:language, :region] => [\"/\", \"/fr\", \"/nl\"]\n      locale_prefix_sources: [:region, :language] => [\"/\", \"/001\", \"/fr\", \"/nl\", \"/be\"]\n\n      ```","ref":"release_notes.html#1-localize-phoenix-routes"},{"type":"extras","title":"2. Localize.Phoenix.Runtime: Advanced Locale Detection - Release Notes","doc":"Routex 1.2.0 automatically detects the user’s locale from multiple independent\nsources:\n\n  - Pre-compiled route attributes\n  - The `Accept-Language` header sent by the client (`fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7`)\n  - Query parameters (`?lang=fr`)\n  - Hostname (`fr.example.com`)\n  - Path parameters (`/fr/products`)\n  - Assigns (`assign(socket, [locale: \"fr\"])`)\n  - Body parameters\n  - Stored cookie\n  - Session data\n\nThe extension comes with sane default, but each parameter can be customized to\nmake locale detection fit your project instead of the other way around. A uniq\nmulti‑attribute, multi-source approach empowers your application to adapt the\nruntime `language` and `region` using different strategies. This aligns with our\n[Localization vs Translation advice](/docs/guides/LOCALIZATION_VS_TRANSLATION.md)\n\n**Example**\n\n```elixir\n# In your Routex backend module; all optional\nlocale_sources: [:query, :session, :accept_language], # Order matters\nlocale_params: [\"locale\"], # Look for ?locale=... etc\n\nlanguage_sources: [:path, :host],\nlanguage_params: [\"lang\"], # Look for /:lang/... etc\n\nregion_sources: [:route] # Only use region from precompiled route attributes\n# region_params defaults to [\"region\"]\n```\n\n\nBy automating locale detection, Routex helps you eliminate error‑prone manual\nsetup and significantly reduces development time.\n\n\n\n#### Extension Development\n\n**Provide LiveView Lifecycle Hooks**\n\n`Routex.Extension.LiveViewHooks` detects LiveView Lifecycle callbacks and\ninlines their bodies. Each callback receives the standard LiveView parameters\nafter `attrs` -containing the current routes' Routex attributes- has been\nembedded in the `socket`.\n\n**Available Callbacks**\n\n- `handle_params`\n- `handle_event`\n- `handle_info`\n- `handle_async`\n- `after_render`\n\n\n**Provide a Plug**\n\n`Routex.Extension.Plugs` detects `call/2` callbacks and inlines their bodies.\nThe callback receives the standard `Plug.call` parameters after `attrs`\n-containing the current routes' Routex attributes- has been embedded in the\n`conn`.","ref":"release_notes.html#2-localize-phoenix-runtime-advanced-locale-detection"},{"type":"extras","title":"Changelog","doc":"# Change Log\n\nAll notable changes to this project will be documented in this file.\nSee [Conventional Commits](Https://conventionalcommits.org) for commit guidelines.\n\n<!-- changelog -->\n\n## [v1.3.0-rc.1](https://github.com/BartOtten/routex/compare/v1.3.0-rc.0...v1.3.0-rc.1) (2025-09-29)","ref":"changelog.html"},{"type":"extras","title":"Bug Fixes: - Changelog","doc":"* core: no matching function clause due to newline metadata.\n\n## [v1.3.0-rc.0](https://github.com/BartOtten/routex/compare/v1.2.4...v1.3.0-rc.0) (2025-09-24)","ref":"changelog.html#bug-fixes"},{"type":"extras","title":"Features: - Changelog","doc":"* implement routex.install task","ref":"changelog.html#features"},{"type":"extras","title":"Bug Fixes: - Changelog","doc":"* mermaid loaded unnecessary\n\n* update default config to match USAGE guide\n\n* igniter installer fails to update Web module\n\n## [v1.2.4](https://github.com/BartOtten/routex/compare/v1.2.3...v1.2.4) (2025-09-06)","ref":"changelog.html#bug-fixes-1"},{"type":"extras","title":"Bug Fixes: - Changelog","doc":"* plug: use URI.parse to support list query params with brackets\n\n## [v1.2.3](https://github.com/BartOtten/routex/compare/v1.2.2...v1.2.3) (2025-09-05)","ref":"changelog.html#bug-fixes-2"},{"type":"extras","title":"Bug Fixes: - Changelog","doc":"* plug pipeline broken for non-routex routes\n\n## [v1.2.2](https://github.com/BartOtten/routex/compare/v1.2.1...v1.2.2) (2025-05-06)","ref":"changelog.html#bug-fixes-3"},{"type":"extras","title":"Bug Fixes: - Changelog","doc":"* processing: order not fully restored\n\n## [v1.2.1](https://github.com/BartOtten/routex/compare/v1.2.0...v1.2.1) (2025-05-05)","ref":"changelog.html#bug-fixes-4"},{"type":"extras","title":"Bug Fixes: - Changelog","doc":"* core: reduction error when all routes are wrapped\n\n* localize: custom route prefix ignored\n## [v1.2.0](https://github.com/BartOtten/routex/compare/v1.1.0...v1.2.0) (2025-05-01)","ref":"changelog.html#bug-fixes-5"},{"type":"extras","title":"New Extensions: - Changelog","doc":"* `Routex.Extension.Localize.Phoenix.Routes` - compile time localization\n\n* `Routex.Extension.Localize.Phoenix.Runtime` - runtime localization\n\n* `Routex.Extension.RuntimeDispatcher` - set state / put locale using route attributes\n\n* `Routex.Extension.LiveViewHooks` - inlines custom LiveView lifecycle hooks provided by other extensions\n\n* `Routex.Extension.Plugs` - detects and inlines custom Plugs provided by other extensions","ref":"changelog.html#new-extensions"},{"type":"extras","title":"Features - Changelog","doc":"* auto detection and usage of existing Cldr, Gettext or Fluent setup.\n\n* support `locales` and `default_locale` for auto generated localized routes\n\n* support attribute overrides for `locale` attributes\n\n* `Routex.Extension.Localize.Registry` - simple locale registry based on IANA\n\n* clear error messages when extensions are missing\n\n* show summary of processed routes\n\n* new config option to inspect generated helpers code","ref":"changelog.html#features-1"},{"type":"extras","title":"Docs - Changelog","doc":"* simplified Usage guide\n\n* improved Localization guide\n\n* updated Comparison guide","ref":"changelog.html#docs"},{"type":"extras","title":"Bug Fixes: - Changelog","doc":"* core: warnings generated by mix docs\n\n* core: compilation failure due to uncompiled backends\n\n* core: compilation lockups / delays","ref":"changelog.html#bug-fixes-6"},{"type":"extras","title":"Tests: - Changelog","doc":"* reached > 90% test coverage\n\n* enforce > 90% test coverage\n\n\n\n## [v1.1.0](https://github.com/BartOtten/routex/compare/v1.0.0...v1.1.0) (2025-02-13)","ref":"changelog.html#tests"},{"type":"extras","title":"Features: - Changelog","doc":"* provide assigns directly in conn\n\n* core: add function to print critical messages","ref":"changelog.html#features-2"},{"type":"extras","title":"Bug Fixes: - Changelog","doc":"* match patterns fail on trailing slash\n\n* undefined on_mount/4, silent missing attrs/1\n\n\n\n\n## [v1.0.0](https://github.com/BartOtten/routex/compare/v0.3.0-alpha.4...v1.0.0) (2025-02-03)","ref":"changelog.html#bug-fixes-7"},{"type":"extras","title":"Features: - Changelog","doc":"* support Phoenix Liveview >= 1.0","ref":"changelog.html#features-3"},{"type":"extras","title":"Bug Fixes: - Changelog","doc":"* ci: upgrade artifact actions in workflow\n\n* core: comp. error - cannot set :__struct__ in struct definition\n\n* incorrect typespecs\n\n* cldr: use territory_from_locale for territory resolution","ref":"changelog.html#bug-fixes-8"},{"type":"extras","title":"v0.x - Changelog","doc":"The CHANGELOG for v0.x releases can be found in the [v0.x branch](https://github.com/BartOtten/routex/blob/v0.x/CHANGELOG.md).","ref":"changelog.html#v0-x"},{"type":"extras","title":"Getting started","doc":"# Usage","ref":"usage.html"},{"type":"extras","title":"Requirements - Getting started","doc":"- Elixir >=1.11\n- Phoenix >= 1.6.0\n- Phoenix LiveView >= 0.16 (optional)","ref":"usage.html#requirements"},{"type":"extras","title":"Adding Routex to your project - Getting started","doc":"You can install this library by adding it to your list of dependencies in\n`mix.exs`. (use `mix hex.info routex` to find the latest version):\n\n```diff\ndef deps do\n  [\n     ...other deps\n+    {:routex, \"~> 1.0\"}\n  ]\nend\n```\n\nNext run:\n```bash\nmix deps.get\n```","ref":"usage.html#adding-routex-to-your-project"},{"type":"extras","title":"Quick config using Igniter - Getting started","doc":"Routex includes an [Igniter](https://hexdocs.pm/igniter/readme.html) install\ntask that automates the setup process, eliminating the need for manual file\nediting.\n\nYou can install Igniter adding it to your list of dependencies in\n`mix.exs`. (use `mix hex.info igniter` to find the latest version):\n\n```diff\ndef deps do\n  [\n     ...other deps\n     {:routex, \"~> 1.0\"},\n+    {:igniter, \"~> 0.6\"}\n  ]\nend\n```\n\nEven though Igniter handles the installation automatically, it's recommended to\nreview the rest of this page to understand how Routex works and how you can\ncustomize it to fit your specific needs.\n\n```bash\nmix deps.get\nmix routex.install\n```","ref":"usage.html#quick-config-using-igniter"},{"type":"extras","title":"Manual config - Getting started","doc":"Modify the entrypoint of your web interface definition.\n```diff\n# file: lib/example_web.ex\n\n# in router\n+  use Routex.Router  # always before Phoenix Router\n   use Phoenix.Router, helpers: false\n\n# in controller\n   unquote(verified_routes())\n+  unquote(routex_helpers())\n\nq\n# in live_view\n      unquote(html_helpers())\n+     on_mount(unquote(__MODULE__).Router.RoutexHelpers)\n\n# in view_helpers or html_helpers\n   unquote(verified_routes())\n+  unquote(routex_helpers())\n\n# insert new private function\n+  defp routex_helpers do\n+    quote do\n+      import Phoenix.VerifiedRoutes,\n+        except: [sigil_p: 2, url: 1, url: 2, url: 3, path: 2, path: 3]\n+\n+      import unquote(__MODULE__).Router.RoutexHelpers, only: :macros\n+      alias unquote(__MODULE__).Router.RoutexHelpers, as: Routes\n+    end\n+  end\n```","ref":"usage.html#manual-config"},{"type":"extras","title":"Configuration - Getting started","doc":"To use `Routex`, a module that calls `use Routex.Backend` (referred to below as a\n\"backend\") has to be defined. It includes a list with extensions and\nconfiguration of extensions.\n\nToo speed up setup all extensions are included in the configuration below.\n\n```elixir\n# file /lib/example_web/routex_backend.ex\n\ndefmodule ExampleWeb.RoutexBackend do\n use Routex.Backend,\n   extensions: [\n     # required\n     Routex.Extension.AttrGetters,\n\n     # adviced\n     Routex.Extension.LiveViewHooks,\n     Routex.Extension.Plugs,\n     Routex.Extension.VerifiedRoutes,\n     Routex.Extension.Alternatives,\n     Routex.Extension.AlternativeGetters,\n     Routex.Extension.Assigns,\n     Routex.Extension.Localize.Phoenix.Routes,\n     Routex.Extension.Localize.Phoenix.Runtime,\n     Routex.Extension.RuntimeDispatcher\n\n     # optional\n     # Routex.Extension.Translations,  # when you want translated routes\n     # Routex.Extension.Interpolation, # when path prefixes don't cut it\n     # Routex.Extension.RouteHelpers,  # when verified routes can't be used\n     # Routex.Extension.Cldr,          # when combined with the Cldr ecosystem\n   ],\n   assigns: %{namespace: :rtx, attrs: [:locale, :language, :region]},\n   verified_sigil_routex: \"~p\",\n   verified_url_routex: :url,\n   verified_path_routex: :path\nend\n```","ref":"usage.html#configuration"},{"type":"extras","title":"Preprocess routes with Routex - Getting started","doc":"`Routex` will preprocess any route found inside a `preprocess_using` block,\neither directly or nested in other blocks such as `scope`.\n\n`preprocess_using` receives the backend module name as the first argument. This\nallows the use of distinct backends per `preprocess_using` block (e.g. to use\ndifferent extensions for admin routes)\n\n```diff\n# file: router.ex\n  pipeline :browser do\n      [..]\n      plug :put_secure_browser_headers\n      plug :fetch_current_user\n+     plug :routex\n  end\n\n+ preprocess_using ExampleWeb.RoutexBackend do\n    scope \"/\", ExampleWeb do\n      pipe_through [:browser, :redirect_if_user_is_authenticated]\n      # [...routes...]\n    end\n\n    scope \"/\", ExampleWeb do\n      pipe_through [:browser, :require_authenticated_user]\n      # [...routes...]\n    end\n+ end\n```","ref":"usage.html#preprocess-routes-with-routex"},{"type":"extras","title":"Configuring individual extensions - Getting started","doc":"In the configuration above, a number of extensions are enabled with sensible\ndefaults to help you get started quickly. Don’t worry though; they’re all highly\ncustomizable, so you can adjust them to fit your needs.\n\nEach extension focuses on a single feature and comes with its own documentation\nthat explains how to set it up and use it. If you’d like a quick overview along\nwith links to the docs for each extension, check out\nthe [Extensions Overview](docs/EXTENSIONS.md).\n\n> #### Broken paths? {: .warning}\n> The [Verified Routes extension](docs/EXTENSIONS.md#verified-routes) is\n> configured to act as drop-in replacements. As a result you might have to\n> rename some `~p` sigils (verified route paths) in (h)eex templates to `~o`\n> where the default _non-branching_ behaviour is required.","ref":"usage.html#configuring-individual-extensions"},{"type":"extras","title":"Help? - Getting started","doc":"When you run into issues, please have a look at the\n[Troubleshooting](docs/TROUBLESHOOTING.md) guide and\n[Elixir Forum](https://elixirforum.com/tag/routex)","ref":"usage.html#help"},{"type":"extras","title":"Localize Phoenix","doc":"This tutorial explains how to use **Routex** to localize your **Phoenix**\napplication including multilingual, SEO-friendly URLs. In addition to showing\nhow to configure Routex, you’ll learn:\n\n- **Why localized routes matter:** Enhance user experience, improve SEO, and support regional content.\n- **How Routex works:** How the battery included framework supports locatization.\n- **Step-by-step setup:** Configure your backend, set up translations, and add a language switcher.","ref":"localize_phoenix.html"},{"type":"extras","title":"What You’ll Build - Localize Phoenix","doc":"By the end of this tutorial, you will have:\n- A set of locale-specific URLs for your product pages.\n- Translated route segments based on your Gettext files.\n- A language switcher component that keeps users within their localized scope.\n- Guidance on further customization and troubleshooting.\n\nFor example, your routes may look like:\n\n```\n                       ⇒ /products/:id/edit                    @loc.locale = \"en_US\"\n   /products/:id/edit  ⇒ /eu/nederland/producten/:id/bewerken  @loc.locale = \"nl_NL\"\n                       ⇒ /eu/france/produit/:id/editar         @loc.locale = \"fr_FR\"\n                       ⇒ /gb/products/:id/edit                 @loc.locale = \"en_GB\"\n```","ref":"localize_phoenix.html#what-you-ll-build"},{"type":"extras","title":"Prerequisites - Localize Phoenix","doc":"- A working Phoenix project with Routex installed. (See [Routex Usage\n  Guide](/USAGE.md) for installation instructions.)\n- Phoenix version ≥ 1.6 and Elixir version ≥ 1.11.","ref":"localize_phoenix.html#prerequisites"},{"type":"extras","title":"Terminology - Localize Phoenix","doc":"Slightly simplified for your convenience.\n\n- `locale`: Formatted as `language`-`region`. \"en-GB\" is\n  shorthand for language \"en\" and region \"GB\".\n- `IANA`: The Internet Assigned Numbers Authority provides an official list\n  of region- and language-identifier including display names\n- `attribute`: custom value assigned to a route\n- `assign`: value accesible using `@key` in templates\n- `Accept-Language`: The HTTP Accept-Language request header indicates the\n   natural language and locale that the _software client_ prefers.\n\n---","ref":"localize_phoenix.html#terminology"},{"type":"extras","title":"Step 1: Configuring the Routex Backend - Localize Phoenix","doc":"Next, create (or update) your Routex backend module. This configuration\ndetermines which extensions to use, how to generate alternative routes, and how\nto integrate translations via Gettext.\n\nAn explanation of the configuration is at the bottom of this guide.\n\n```elixir\ndefmodule ExampleWeb.RoutexBackend do\n  @moduledoc \"\"\"\n  Configures Routex to enable localized and translated routes.\n  \"\"\"\n\n  use Routex.Backend,\n    extensions: [\n      # == Base extensions ==\n      Routex.Extension.AttrGetters,         # Base attribute handling\n      Routex.Extension.LiveViewHooks,       # Inlines LiveView lifecycle callbacks of other extensions\n      Routex.Extension.Plugs,               # Inlines plug callbacks of other extensions\n      # == Used for Localization ==\n      Routex.Extension.Localize.Phoenix.Routes,     # Localize routes at compile time\n      Routex.Extension.Localize.Phoenix.Runtime,    # Detects locale from various sources at runtime\n      Routex.Extension.Translations,                # Enables route segment translations\n      Routex.Extension.Alternatives,                # Generates locale alternatives set by Localize.Phoenix\n      Routex.Extension.AlternativeGetters,          # Creates a helper function to get the alternatives for a route\n      Routex.Extension.VerifiedRoutes,              # Make Phoenix VerifiedRoutes branch (alternatives) aware\n      Routex.Extension.RuntimeDispatcher,           # Dispatches during runtime (e.g `Gettext.put_locale/{1,2}`)\n    ],\n\n    # Integration with Gettext for route segment translation.\n    # Defaults to the standard Gettext module of a Phoenix project.\n    # translations_backend: ExampleWeb.Gettext,\n\n    # Drop-in replacements: Override Phoenix VerifiedRoutes macros with Routex variants.\n    verified_sigil_routex: \"~p\",\n    verified_sigil_phoenix: \"~o\",\n    verified_url_routex: :url,\n    verified_path_routex: :path,\n\n    # Locales to generate routes for: English (Global), Dutch, French, English (Great Brittain) and English (European)\n    # All optional. `locales` and `default_locale` will be detected using Cldr, Gettext or Fluent when available.\n    # locales: [{\"en-001\", %{region_display_name: \"Worldwide\"}}, \"nl-NL\", \"fr-FR\", \"en-GB\", \"en-150\"],\n    # default_locale: \"en-100\",\n\n    # Custom language detection source priority\n    # language_sources: [:query, :session, :cookie, :attrs, :accept_language],\n\n    # Runtime dispatch targets to set Gettext locale from route attribute :language.\n    # Shown below is the default.\n    # dispatch_targets: [{Gettext, :put_locale, [[:attrs, :language]]}]\nend\n```\n\n\n---","ref":"localize_phoenix.html#step-1-configuring-the-routex-backend"},{"type":"extras","title":"Step 2: Translate Route Segments - Localize Phoenix","doc":"Generate the translation files for your routes:\n\n```bash\nmix gettext.extract\nmix gettext.merge priv/gettext --locale nl\nmix gettext.merge priv/gettext --locale fr\n```\n\nThis creates the following structure:\n\n```text\npriv/\n gettext/\n   nl/\n     LC_MESSAGES/\n       default.po  # phoenix translations\n       routes.po   # routex translations\n    fr/\n     LC_MESSAGES/\n       default.po  # phoenix translations\n       routes.po   # routex translations\n```\n\nTranslate your route segments using any `.po` file editor (Poedit, OmegaT, etc.).\n\nAfter you have translated segments, run `mix compile --force` for trigger a\nrecompilation with translated routes.\n\n---","ref":"localize_phoenix.html#step-2-translate-route-segments"},{"type":"extras","title":"Step 3: Adding a Language Switcher Component - Localize Phoenix","doc":"To improve user experience, add a component that lets users switch locales\nseamlessly. Below is an example using a LiveView component with explicit styling\nand accessibility features:\n\n```heex\n<.link\n  :for={alternative <- Routes.alternatives(@url)}\n  class=\"button\"\n  rel=\"alternate\"\n  hreflang={alternative.attrs.language}\n  navigate={alternative.slug}>\n  <.button class={if(alternative.match?, do: \"bg-[#FD4F00]\", else: \"\")}>\n    <%= alternative.attrs.language_display_name %>\n  </.button>\n</.link>\n```","ref":"localize_phoenix.html#step-3-adding-a-language-switcher-component"},{"type":"extras","title":"Component Highlights: - Localize Phoenix","doc":"- **Looping over Alternatives:** Fetches all localized route variants for the current URL.\n- **User Friendly Language Names:** Uses the `:language_display_name` as set by Localize.\n- **Dynamic Styling:** Highlights the current language (using a conditional CSS class).\n- **Accessible Markup:** Uses proper `rel` and `hreflang` attributes.\n\n> **Next Steps:** Customize further using Tailwind CSS or your preferred\n> framework and ensure it meets accessibility standards.\n\n---","ref":"localize_phoenix.html#component-highlights"},{"type":"extras","title":"Troubleshooting & Testing - Localize Phoenix","doc":"","ref":"localize_phoenix.html#troubleshooting-testing"},{"type":"extras","title":"Common Pitfalls: - Localize Phoenix","doc":"- **Missing Translation:** Ensure your PO files are updated and merged after any change.\n- **Route Mismatch:** Run `mix phx.routes` to verify that all localized routes are generated.\n- **Cookie/Session Issues:** Double-check your browser settings if locale detection does not work as expected.\n\n---","ref":"localize_phoenix.html#common-pitfalls"},{"type":"extras","title":"Additional Features & Customization - Localize Phoenix","doc":"- **Extending Functionality:** If you need more complex transformations,\n  consider writing your own Routex extension. The [Extension Development\n  Guide](/docs/EXTENSION_DEVELOPMENT.md) offers detailed instructions.\n- **Combining with Other Extensions:** Routex extensions are designed to work\n  seamless together. Other extensions can be found in the [List of Routex\n  Extensions](/docs/EXTENSIONS.md)\n- **Enhance Usability:** Read our guide [Localization vs. Translation: Why Your\n  Website Should Keep Them Separate](/docs/guides/LOCALIZATION_VS_TRANSLATION.md)\n\n---","ref":"localize_phoenix.html#additional-features-customization"},{"type":"extras","title":"Conclusion - Localize Phoenix","doc":"This tutorial has guided you through localizing your Phoenix routes using Routex by:\n- Explaining the benefits of localized routes.\n- Providing a detailed configuration example with clear commentary.\n- Demonstrating how to extract translations and build a language switcher.\n- Offering troubleshooting and testing recommendations.\n\nBy following these steps, you now have a powerful and flexible routing system\nthat can adapt to any locale requirement without modifying your templates. For\nfurther enhancements, check the official Routex documentation and join the\ndiscussion on the [Elixir Forum](https://elixirforum.com/tag/routex).\n\nHappy coding and enjoy creating a multilingual Phoenix application!\n\n\n---","ref":"localize_phoenix.html#conclusion"},{"type":"extras","title":"The Configuration Explained - Localize Phoenix","doc":"**AttrGetters, LiveViewHooks, Plugs**:\n  - Extensions supporting other extensions.\n\n**Alternatives Structure**:\n  - Creates a hierarchical URL structure\n  - Supports regional variations (e.g., European vs British English)\n  - Associates locales with URL paths\n  - Supports `[language|region]_display_name` overrides\n\n**Localize with custom language sources**:\n  - Expands route attribute `:locale` into route attributes `:locale, :region, :language, :region_display_name, :language_display_name`\n  - Handles locale detection using a variery of sources including `Accept-Language`\n  - Sets attributes `:locale`, `:region` and `:language` at runtime\n  - Comes with an IANA-based locale registry to validate locale-, region- and language and to convert these to display names\n  - Custom detection source priority to favor the routes' language over the `Accept-Language` browser language\n\n**Translation Setup**:\n  - Enables path segment translation\n  - Uses the default translation lib use by Phoenix: Gettext.\n  - Consistent segment localization\n\n**Verified Routess**:\n  - Preserves existing Phoenix path sigils (e.g. `~p\"/my/path\"`)\n  - Adds locale awareness to routes\n  - Maintains backward compatibility\n\n **AlternativeGetters**:\n  - Fetch alternative locale routes using `alternatives(@url)`\n  - Use to generate buttons to switch language\n\n**RuntimeDispatcher**:\n - Configured to call `Gettext.put_locale`\n - Uses the runtime detected attribute `:language` which is set by Localize.","ref":"localize_phoenix.html#the-configuration-explained"},{"type":"extras","title":"Localization vs Translation","doc":"# **Localization vs. Translation: Why Your Website Should Keep Them Separate**\n\nWhen expanding a website for a global audience, businesses often confuse\n**translation** with **localization**. While they are related, treating them as\nthe same process can lead to usability issues and a poor user experience.\nAdditionally, many websites make the mistake of assuming that a user's\n**preferred language** matches their **physical location**, which can cause\nfrustration.\n\nIn this post, we’ll break down the differences between translation and\nlocalization, why your website should separate them, and why **language\npreferences should not be tied to a user's location**.","ref":"localization_vs_translation.html"},{"type":"extras","title":"The Problem: Conflating Location and Language - Localization vs Translation","doc":"Many websites make the mistake of assuming that location dictates language.\nWhile there's often a correlation, it's far from a perfect match. Think about\nit:\n\n* **Multilingual Regions:** Countries like Switzerland, Canada, and Belgium have\n  multiple official languages. A user in Switzerland might prefer to browse in\n  German, French, or Italian. Assuming their language based on their IP address\n  (which indicates location) would be inaccurate.\n\n* **Expatriates and Travelers:** Someone living abroad might prefer to browse in\n  their native language, even if they're physically located in a different\n  country. A German expat in Spain might still want to see the website in\n  German.\n\n* **Language Learning:** Some users might prefer to browse in a language they're\n  learning, regardless of their location.\n\n* **Shared Computers:** In internet cafes, libraries, or shared family\n  computers, users might not have control over the browser's language settings.\n  Relying on these settings can lead to an incorrect language selection.\n\n**The Problem with `Accept-Language` HTTP Header:**\n\nWebsites often use the `Accept-Language` HTTP header, sent by the browser, to\ndetermine the user's preferred language. While this can be helpful, it's not\nfoolproof. As mentioned above, on shared computers, the `Accept-Language` header\nmight reflect the preferences of a previous user. Users might also not know how\nto change this setting, or it might be locked by system administrators in\ncertain environments. Therefore, relying solely on this header can lead to a\nfrustrating experience.\n\n**Examples of What *Not* to Do:**\n\n* **Automatic Redirection Based on IP:** A user in Canada is automatically\n  redirected to the French version of the site, even though their browser and\n  system language are set to English. This is a classic example of location\n  overriding language preference.\n\n* **Flag Icons as Language Options:** Using flag icons to represent language is\n  problematic. Flags represent countries, not languages. What about Spanish\n  speakers in the US? Or English speakers in India? This conflates nationality\n  with language.\n\n* **Hidden Language Settings:** Language options are buried deep in the footer\n  or only appear after navigating through several pages. Users shouldn't have to\n  hunt for their preferred language.\n\n* **Sole Reliance on `Accept-Language`:** The website assumes the browser's\n  language setting is the user's actual preference, ignoring the possibility of\n  shared computers or incorrect settings.","ref":"localization_vs_translation.html#the-problem-conflating-location-and-language"},{"type":"extras","title":"The Solution: Always Give Users Control - Localization vs Translation","doc":"The key is to treat location and language as distinct, yet related, pieces of\ninformation *and always give users explicit control over both*. Here's how to do\nit right:\n\n* **Explicit Language Selection:** Provide clear and prominent language options,\n  ideally using the language name itself (e.g., \"English,\" \"Español,\" \"Deutsch\")\n  rather than flags. Place these options in a visible location, such as the\n  header or footer, *on every page*.\n\n* **Location as a Secondary Consideration:** Use location data (IP address) to\n  *suggest* a default language and/or currency, but *always* allow the user to\n  override this suggestion. A simple popup or banner saying \"We've detected\n  you're in [Location]. Would you like to view the site in [Suggested Language]?\n  [Yes/No]\" is a good approach. Even if they click \"yes,\" the language option\n  should *still* be readily available.\n\n* **User Profiles and Preferences:** For returning users, store their language\n  and location preferences in their user profile. This ensures a consistent\n  experience across sessions.\n\n* **Content Localization, Not Just Translation:** Consider cultural nuances and\n  adapt content accordingly. Simply translating text without considering\n  cultural context can be ineffective or even offensive. Dates, times, and units\n  of measurement should also be localized.\n\n* **Clear Location Settings:** If location-specific content is crucial (e.g.,\n  store locator, shipping information), provide a separate and easy-to-use\n  location selection mechanism. This could be a dropdown menu or a map\n  interface.\n\n**Example of How to Do It Right:**\n\n* A user lands on a website and sees a small popup: \"We've detected you're in\n  the UK. Would you like to view prices in GBP and the site in English?\n  [Yes/No]\"\n\n* *Regardless* of the user's choice in the popup, a language dropdown menu is\n  *always* visible in the header, offering options like \"English,\" \"Français,\"\n  \"Español,\" etc.\n\n* The footer contains a link to \"Change Location,\" where the user can specify\n  their country for location-specific content.\n\nBy implementing these best practices, websites can create a more inclusive and\nuser-friendly experience for their global audience. Respecting the distinction\nbetween location and language, and *always giving users the control to choose*,\nis not just good practice, it's essential for building trust and maximizing your\nonline reach.","ref":"localization_vs_translation.html#the-solution-always-give-users-control"},{"type":"extras","title":"How Routex' approach helps - Localization vs Translation","doc":"Routex's approach to localized routing reinforces the principle of keeping\nlanguage and location distinct. No implicit information is embedded in the\nroutes.\n\nWhen dealing with **region-based pages** changing a user's region (and thus the\nassociated region-specific content) doesn't necessitate an automatic language\nswitch. And when dealing with **language-based pages** changing a user's\nlanguage doesn't necessitate an automatic region switch.\n\nImagine a scenario where a user is browsing a **region-based** site in English\nbut wants to see the pricing and product availability for the Indian market.\nWith Routex, they can navigate to the India region-specific page (e.g.,\n/in/products) without being forced to switch to another language. The site can\nmaintain the user's preferred language (English in this case) while displaying\nthe relevant Indian content.\n\nThis is in stark contrast to systems where language and region are implicitly\nlinked. In such cases, switching regions might inadvertently trigger a language\nchange, leading to a confusing and frustrating user experience.\n\n\n## **Conclusion**\n\nLocalization and translation serve different purposes and should be handled\nseparately to provide the best user experience. Similarly, **a user's preferred\nlanguage should not be assumed based on their location**. By keeping these\nelements distinct, websites can ensure better usability, compliance, and\nengagement for a global audience.\n\nBy adopting **a user-first approach**, where language is a choice and location\nis used only for relevant regional settings, businesses can create a seamless,\naccessible, and culturally appropriate experience for all users.","ref":"localization_vs_translation.html#how-routex-approach-helps"},{"type":"extras","title":"Routex and Phoenix Router","doc":"# How Routex and Phoenix Router Work Together: A Blueprint for Understanding\n\n \n All code on this page is for illustration purpose only. It is incorrect and\n should not be used.\n \n\nHow Routex, its extensions, and the Phoenix Router work together can be better\nunderstood through an analogy. As the saying goes, \"a picture is worth a\nthousand words,\" this document also includes an illustrative blueprint.","ref":"routex_and_phoenix_router.html"},{"type":"extras","title":"Analogy: the housing project - Routex and Phoenix Router","doc":"Imagine you're a *real estate developer* planning to build several houses. You\nhave a general vision for the houses (your route definitions in `route.ex`) and\nsome specific ideas about their style and features (your Routex configuration).\n\n```\n# routes\n/products\n/products/:id\n\n# config\nalternatives: %{\n    \"/fr\" => %{name: \"French\"},\n    \"/es\" => %{name: \"Spanish\"}\n}\n```\n\nRoutex is the *architect*. It takes your vision (route definitions) and\npreferences (Routex config) and creates detailed blueprints.\n\nRoutex extensions are the *architect's specialized tools*. These tools allow the\narchitect to refine and customize the blueprints. Without them, the architect\ncould only create basic, unmodified plans.\n\n```\n# input\n[\n%Route{path: \"/products\"}\n%Route{path: \"/products/:id\"}\n]\n\n# output after transformation by Alternatives extension\n[\n%Route{path: \"/fr/products\",      metadata: %{name: \"French\"}},\n%Route{path: \"/fr/products/:id\",  metadata: %{name: \"French\"}},\n%Route{path: \"/es/products\",      metadata: %{name: \"Spanish\"}},\n%Route{path: \"/es/products/:id\",  metadata: %{name: \"Spanish\"}}\n]\n```\n\nOnce the blueprints are finalized, they're handed off to the *construction\ncompany*: Phoenix Router. Phoenix Router builds the actual houses (your routes)\naccording to the architect's precise specifications. The blueprints are\nperfectly formatted for Phoenix Router, ensuring a smooth construction process.\n\n```\n# note: incorrect pseudo code\n\nif match?(\"/fr/products\"      ), do: ProductLive, :index, metadata: [\"French\"]\nif match?(\"/fr/products/\" <> id), do: ProductLive, :show,  metadata: [\"French\"]\nif match?(\"/es/products\"      ), do: ProductLive, :index, metadata: [\"Spanish\"]\nif match?(\"/es/products/\" <> id), do: ProductLive, :show,  metadata: [\"Spanish\"]\n```\n\nThis explains the first key concept:\n\n> **Routex generates blueprints from your route definitions and configuration,\n> ready for Phoenix Router to build the actual routes.**\n\nBecause Routex is the architect, it has intimate knowledge of the house designs.\nThis allows it to create perfectly matching accessories, like custom-designed\nsunshades or smart garage doors. These are *additional* features that enhance\nthe houses built by Phoenix Router, adding convenience and functionality.\n\n```\n# generated convenient functions\ndefmodule Helpers do\n  def alternatives(\"/products\") do\n    [\n      %Route{path: \"/fr/products\", name: \"French\"},\n      %Route{path: \"/es/products\", name: \"Spanish\"}\n    ]\n  end\nend\n\n# your usage\nThis page is available in:\nfor alt <- Helpers.alternatives(\"/products\") do\n <.link navigate={alt.path}>{alt.name}<./link>\nend\n\n# output\nThis page is available in:\n French \n Spanish \n```\n\nThis leads to the second key concept:\n\n> **Routex also creates helpful accessory functions that you can use with the\n> houses (routes) built by Phoenix Router.** These functions streamline common\n> tasks and improve the overall experience.","ref":"routex_and_phoenix_router.html#analogy-the-housing-project"},{"type":"extras","title":"Example blueprint - Routex and Phoenix Router","doc":"A picture paints a thousand words, or so they say. The blueprint clearly shows\nhow Routex is middleware, plugged between two stages of Phoenix route generation.\n\nAlso shown is the use two co-operating extensions: `Translations` uses the\n`:language` attribute set by `Alternatives`.\n\n \nflowchart TD\n subgraph subGraph1[\"Routex\"]\n        F[\"ExampleWeb.RoutexBackend.ex\"]\n        G[\"configure/2 callbacks\"]\n        H[\"Alternatives.transform/3 callback\"]\n        I[\"Translations.transform/3 callback\"]\n        J[\"create_helpers/3 callbacks\"]\n     K[\"ExampleWeb.Router.RoutexHelpers\"]\n  end\n  subgraph subGraph0[\"Phoenix\"]\n        A[\"ExampleWeb.Router.ex\"]\n        B[\"Convert to Phoenix.Routes.Route structs\"]\n        C[\"Generate route functions\"]\n        D[\"ExampleWeb.Router\"]\n  end\n  A -- \"/products/:id\" --> B\n  B -- \"%{path: /products/:id}\" --> H\n  F -- \"extensions: [Alternatives, Translations]\" --> G\n  G --> H\n  H -- \"%{path: ..., attrs: %{lang: fr}}\n       %{path: ..., attrs: %{lang: es}}\" --> I\n  I -- \"%{path: /produit/:id, attrs: ...}\n       %{path: /producto/:id, attrs: ...}\" --> C & J\n  C -- \"def match?(/produit/:id), do: ProductController\n      def match?(/producto/:id), do: ProductController\" --> D\n  J -- \"def alternatives(/products/:id) do\n        %{path: /produit/:id, attrs: %{lang: fr}}\n        %{path: /producto/:id, attrs: %{lang: es}}\n      end\" --> K\n\n  F:::routex\n  G:::routex\n  H:::routex\n  I:::routex\n  J:::routex\n  K:::routex\n  A:::phoenix\n  B:::phoenix\n  C:::phoenix\n  D:::phoenix\n classDef routex  fill:#4d4d4d, stroke:#888, stroke-width:2px, color:#ffffff\n classDef phoenix  stroke-width:1px, stroke-dasharray: 0, stroke:#616161, fill:#FF6D00, color:#424242\n style subGraph0 fill:#FFFFFF, stroke:#757575\n style subGraph1 fill:#FFFFFF, stroke:#757575\n \n\n\n  \n \n  let initialized = false;\n\n  window.addEventListener(\"exdoc:loaded\", () => {\n    if (!initialized) {\n      mermaid.initialize({\n        startOnLoad: false,\n        theme: document.body.className.includes(\"dark\") ? \"dark\" : \"default\"\n      });\n      initialized = true;\n    }\n\n    let id = 0;\n    for (const preEl of document.querySelectorAll(\"pre.mermaid\")) {\n      const graphDefinition = preEl.textContent;\n      const graphEl = document.createElement(\"div\");\n      const graphId = \"mermaid-graph-\" + id++;\n      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {\n        graphEl.innerHTML = svg;\n        bindFunctions?.(graphEl);\n        preEl.insertAdjacentElement(\"afterend\", graphEl);\n        preEl.remove();\n      });\n    }\n  });","ref":"routex_and_phoenix_router.html#example-blueprint"},{"type":"extras","title":"Conclusion - Routex and Phoenix Router","doc":"Phoenix Router and Routex, along with its extensions, form a powerful\npartnership that empowers you to build any route in your web application. Routex\nexpertly designs the intricate pathways of your application's URLs, while\nPhoenix Router flawlessly constructs them, ensuring a smooth and efficient user\nexperience.","ref":"routex_and_phoenix_router.html#conclusion"},{"type":"extras","title":"History of Routex","doc":"","ref":"history_of_routex.html"},{"type":"extras","title":"Summary - History of Routex","doc":"From its humble beginnings as PhxAltRoutes—a proof-of-concept for localized\nrouting in Phoenix—to the modular, extension-driven framework that Routex is\ntoday, this is the story of how community feedback, design constraints, and the\nimmutable spirit of Elixir shaped a next-generation routing library. Along the\nway, we’ll trace the key design pivots that led to Routex’s pluggable core,\nshim-based integration, and stateless, inspectable architecture.","ref":"history_of_routex.html#summary"},{"type":"extras","title":"Origins: PhxAltRoutes and the Rise of Localized Routing - History of Routex","doc":"The concept of compile-time generation of localized and translated routes (using\nGettext) first emerged back in March 2021 when I, Bart Otten, [first posted about\nPhxAltRoutes](https://elixirforum.com/t/reality-check-your-library-idea/32840/30)\nto be followed by a post in Februari 2022 [asking the community for feedback and\ncollaboration](https://elixirforum.com/t/library-for-localized-multilingual-routes-in-phoenix/46233).\n\nThe early review phase resulted in PhxAltRoutes being renamed **Phoenix\nLocalized Routes (PLR)** to better reflect its main use case and the\nintroduction of the PhxAltRoutes-inspired **Cldr-Routes** in late March 2022 by\nthe maintainer of Cldr.\n\nWith two libs in production, developers could write:\n\n```elixir\n# Import localized route macros\nuse Phoenix.LocalizedRoutes  # or Cldr.Routes\n\nlocalize do\n  get \"/pages/:page\", PageController, :show\n  resources \"/users\", UserController\nend\n```\n\nAnd have their routes expanded to localize routes at compile time. Great!","ref":"history_of_routex.html#origins-phxaltroutes-and-the-rise-of-localized-routing"},{"type":"extras","title":"Localized Routes: Promise and Pain Points - History of Routex","doc":"But as usage grew, so did the cracks:\n\n1. **Code Duplication**: PLR and Cldr-Routes forked bits of Phoenix’s router\n   internals, making every upstream Phoenix update a potential breaking change.\n2. **Monolithic Design**: Projects needing PLR for one feature faced the full\n   library, leading to bloat. Cldr-Routes -being an extension itself- needs the\n   Cldr base library to function. If you are not (yet) into the Cldr ecosystem,\n   I consider it a heavy weight to pull in and configure.\n3. **One-Size-Fits-All**: From greenfield apps to legacy codebases, each\n   project’s needs varied— both PLR and Cldr-Routes don’t or didn't adapt the way\n   I envisioned.\n4. **Maintenance Overhead**: Every new route feature forced code changes across\n   user projects, straining both library and app maintainers.\n5. **Stateful Routing**: PLR and Cldr-Routes lean on process state, a mismatch\n   with Elixir’s immutable ethos.\n\nThese lessons set the stage for a reinvented approach.","ref":"history_of_routex.html#localized-routes-promise-and-pain-points"},{"type":"extras","title":"Reinventing (Localized) Routing: Birth of Routex - History of Routex","doc":"In early 2023, I sketched out a fresh vision: a **slim core** with **pluggable\nextensions**, a name that hinted at both routing and extensibility—**Routex**.\n\n> *“Route + Elixir. Route + Extensions. Route + Extendable—pick your flavor.”*\n\nKey principles emerged:\n\n- **Only What You Need**: A minimal core handles just the essentials; extensions\n  add features as needed.\n- **Shim, Don’t Copy**: Rather than replicating Phoenix internals, shim public\n  APIs and delegates to the official public Phoenix functions, so upstream\n  changes flow through automatically.\n- **Stateless by Default**: No process state. (Alternative) Route lookup remains\n  pure and immutable, fitting Elixir’s design philosophy.\n- **Inspectability**: Route definitions flow through **opts** and **structs**,\n  making callbacks transparent and chainable.\n- **Configuration-Driven**: Add features by toggling extensions in config—no\n  code scattering.","ref":"history_of_routex.html#reinventing-localized-routing-birth-of-routex"},{"type":"extras","title":"Core Architecture and Extensibility - History of Routex","doc":"At the heart of Routex is a processing pipeline: It takes the routes and a list\nof extensions and reduces the list of extensions with the routes as argument.\n\nAs a result, the extensions -implementing one or more of four well-defined\ncallbacks: `configure/2`, `transform/3`, `post_transform/3`, and\n`create_helpers/3`- receive inspectable route structs and opts, allowing\ntransparent, composable modifications.\n\nMeanwhile, `Routex.Attrs` provides a shared metadata store so extensions like\n`Routex.Extension.Localize.Phoenix.Runtime` (for runtime locale detection) and\n`Routex.Extension.Translations` (for translated route paths) can cooperate\nwithout stepping on each other’s toes.","ref":"history_of_routex.html#core-architecture-and-extensibility"},{"type":"extras","title":"Immutability and Pattern Matching in Action - History of Routex","doc":"Under the hood, Routex uses immutable pattern matching to transform\nnormal routes into branch aware (auto-scoping) routes.\n\nThis is different from some other libraries that use mutable (process-bound)\nstate. It's a subtle difference, but one that matters.\n\n\n```elixir\n# Pseudo code: The mutable way (aka: standard Javascript demo)\n\n# Somewhere in your templates a link to 'products' in the current scope.\n Products  # => /products\n\nfor locale <- [\"en\", \"fr\"] do\n  put_locale(locale)  # setting state\n   {locale} \nend\n\n# Somewhere in a used component a link to products...guess in which scope.\n Products \n\n```\n\nRoutex does it different, pure. At compile time it generates url pattern\nmatching helpers. As a result, no state is involved and Routex is not coupled to\nthe current process.\n\n```elixir\n# Pseudo code: The immutable Routex way (simplified)\n\n# Somewhere in your templates a link to products in the current scope.\n Products  # => /products\n\n# inefficient use for demonstration purpose\nfor locale <- [\"en\", \"fr\"] do\n  alt = alternatives(@url)[locale]\n   {locale} \nend\n\n# Somewhere in a used component a link to 'products' in the current scope.\n Products \n```\n\nNo hidden state. No surprises. Just Elixir.","ref":"history_of_routex.html#immutability-and-pattern-matching-in-action"},{"type":"extras","title":"Configuration above all else - History of Routex","doc":"The development of Routex has a mission credo: \"Simple by default, powerful when\nneeded\". Setup should be minimal, yet you should be able to adapt Routex to your\nproject instead of the other way around like previous attempts.\n\nFor example, the `Routex.Extension.VerifiedRoutes` lets you customize the sigil\nletter and helper names. These can be set to match Phoenix’s defaults -to avoid\ntemplate churn- or those of Cldr-Routes -to ease migration-. As such, a project\ncan opt into (locale) branch aware Verified Routes by Routex seamlessly—no hard\nforks in your code.","ref":"history_of_routex.html#configuration-above-all-else"},{"type":"extras","title":"Localization Reimagined with Localize.Phoenix - History of Routex","doc":"With the groundwork laid, I revisited the original primary use case early 2025:\nlocalization. This time however, it was just an optional use case out of\nmultiple supported by Routex instead of the only one. Its implementation is a\ntestament to the design choices made upfront.\n\n`Routex.Extension.Localize.Phoenix` offers:\n\n- Automated Plug and LiveView integration at runtime.\n- A minimal locale registry based on IANA standards.\n- Customizable locale detection strategies.\n- Support for multiple locale backends.\n- All configured via a few entries in config.exs, with no changes to route\n  definitions or templates.","ref":"history_of_routex.html#localization-reimagined-with-localize-phoenix"},{"type":"extras","title":"Community Feedback and the Road Ahead - History of Routex","doc":"Looking forward, the vision remains clear: empower developers to craft custom\nrouting logic with minimal friction, leverage Elixir’s immutability, and foster\na vibrant ecosystem of extensions. Routex is designed to grow with your\napplication, not weigh it down.\n\n> *“Routing should adapt to every project’s needs, without forcing projects to\n> adapt to the router.”*\n\nAnd that’s how PhxAltRoutes evolved, lessons were learned, and Routex was\nborn—ready to supercharge Phoenix routing with extension-driven superpowers!\n\n*— Bart Otten*","ref":"history_of_routex.html#community-feedback-and-the-road-ahead"},{"type":"extras","title":"Routing solutions compared","doc":"# Routing Solutions for Phoenix: A Developer-Centric Comparison\n\nWhen building applications with the Phoenix framework, you might need additional\nrouting solutions. Requirements can range from the common internationalization\nand localization to more exotic such as route obfuscation. Selecting the right\ntool is essential. This article compares two libraries that extend the Phoenix\nRouter: **Cldr Routes** and **Routex**.\n\nWe’ll examine differences in functionality, extensibility, integration, runtime\ncapabilities, and customization. By the end, you’ll have a clearer picture of\neach solution’s strengths and limitations to help you decide which is best for\nyour project.","ref":"comparison.html"},{"type":"extras","title":"Summary - Routing solutions compared","doc":"Both Cldr Routes and Routex extend Phoenix Router in meaningful ways.\n\n**Cldr Routes**  \nCldr Routes provides route translation and generates localized path and URL\nhelpers. While Cldr Routes streamlines the process of creating localized routes,\nit necessitates proper configuration of both Cldr and Gettext. This requirement\nis advantageous for projects already utilizing these libraries but may involve\nadditional setup for others.\n\nCldr Routes is particularly well-suited for applications that are already part\nof the Cldr ecosystem and require straightforward URL translations.\n\n**Routex**  \n​Routex is a comprehensive routing framework built on Phoenix Router, offering\nextensive internationalization and localization features that encompass all\ncapabilities of Cldr Routes. Beyond these, Routex introduces a versatile set of\nfunctionalities, including runtime support through built-in Plug and LiveView\nlifecycle hooks, as well as customizable function callbacks for navigation\nevents. ​\n\nA key strength of Routex lies in its seamless integration with existing\ncodebases, preserving established patterns. Its modular architecture and\nextensive customization options enable developers to incorporate custom route\nattributes and alternative routing strategies with minimal disruption. This\nflexibility ensures that Routex can adapt to the specific needs of any project,\nenhancing routing capabilities without necessitating significant codebase\nmodifications. ​\n\nRoutex is recommended for new projects or projects needing to retrofit routing\nfeatures into the existing code bases. Its focus on developer experience means\nyou spend less time configuring and more time building innovative\napplications.For projects invested in Cldr it offers `Routex.Extension.Cldr` as\na convenient adapter mimicing Cldr Routes.","ref":"comparison.html#summary"},{"type":"extras","title":"Tabular comparison - Routing solutions compared","doc":"A quick overview before diving into a detailed explanation:\n\n| **Feature**             | **Routex**            | **Cldr Routes**            |\n| Localized routes        | Yes                   | Yes                        |\n| Translated routes       | Yes                   | Yes                        |\n| Verified Routes         | Yes                   | Yes                        |\n| Route interpolation     | Yes                   | Yes                        |\n| Alternatives routes     | Yes                   | Limited                    |\n| Custom attributes       | Yes                   | No                         |\n| Custom assigns          | Yes                   | No                         |\n| Plug & Hooks            | Yes                   | No                         |\n| Navigation callbacks    | Yes                   | No                         |\n| Buildin locale registry | Yes                   | No                         |\n| Route Obfuscation       | Yes                   | No                         |\n|                         |                       |                            |\n| **Integration**         | **Routex**            | **Cldr Routes**            |\n| Sigils                  | Customizable          | Fixed                      |\n| Functions               | Customizable          | Fixed                      |\n| Libs integration        | Configurable          | None                       |\n| Dependencies            | Configurable          | Cldr, Gettext              |\n| Runtime integration     | Automated             | None                       |\n|                         |                       |                            |\n| **Development**         | **Routex**            | **Cldr Routes**            |\n| Architecture            | Modular               | Monolithic                 |\n| Feature inclusion       | Upstream or extension | Upstream or own fork       |\n| Internal format         | Route structs         | Abstract Syntax Tree (AST) |\n| Tooling included        | Yes                   | No                         |","ref":"comparison.html#tabular-comparison"},{"type":"extras","title":"Feature Set & Extensibility - Routing solutions compared","doc":"Both libraries were inspired by PhxAltRoutes—a pioneering localized\nrouting effort by Routex’s creator—but have since taken distinct evolutionary\npaths.\n\n**Cldr Routes**  \nReduced the feature set to localization features only. Aligning with the goals\nof Cldr.\n\n- **Localization:** Translates URL path segments at compile time and generates\n  localized helper functions.\n- **Fixed Integration:** Relies on the Cldr and Gettext libraries for\n  localization.\n\n**Routex**  \nDesigned to be modular; allowing to grow the feature set beyond localization\nwithout becoming a large monolithic lib and supporting extension orchestration through\nvalue passing.\n\n- **Comprehensive Feature Set:** Beyond matching the internationalization and\n  localization capabilities of Cldr Routes, Routex also offers advanced features\n  like custom assigns, alternative route generation, and support for route\n  segment reordering —providing unmatched flexibility\n- **Integrated Extensions:** Built-in support for Plugs and LiveView lifecycle\n  hooks automates integrations and speeds up development.\n- **Integrated locale registry:** Routex comes with a simplified -IANA subtag\n  registry based- locale registry . It covers common localisation use cases such as\n  translating locale, region and language identifiers to display names and\n  validating locale tags.\n- **Modular Architecture:** Its extension-driven architecture allows you to\n  include only the features you need and easily create custom extensions.\n- **Focus on Customization:** The mantra \"Simple by default, powerful when\n  needed\" drives the development of extensions. Extensions ship with sane\n  defaults yet are highly tweakable due to a sheer amount of configuration\n  options.\n- **Tailor-Made Customization:** Its modular architecture and the information\n  sharing system `Routex.Attrs` lets you extend functionality without having to\n  worry about the core of routing or breaking other extensions. Clone an\n  extension, tweak it to your needs, or build new ones from scratch.\n\nBelow is a feature comparison summarizing key differences:","ref":"comparison.html#feature-set-extensibility"},{"type":"extras","title":"Localized Routes - Routing solutions compared","doc":"While both libraries feature localized routes, Routex offers customization\noptions such a customized locale notation and display name overrides for\nlanguages and regions.","ref":"comparison.html#localized-routes"},{"type":"extras","title":"Translated Routes - Routing solutions compared","doc":"While both libraries feature translate routes by depending on Gettext, Routex\nonly depends on Gettext when the Translations extension is enabled.","ref":"comparison.html#translated-routes"},{"type":"extras","title":"Route Manipulation - Routing solutions compared","doc":"Both libraries feature route manipulation in different degrees. Transformations\nby Cldr Routes are limited to localization. Routex, in contrast, allows for any\nkind of transformation including custom attributes, non-locale alternative\nroutes, and route segment reordering.","ref":"comparison.html#route-manipulation"},{"type":"extras","title":"Plug & LiveView Integration - Routing solutions compared","doc":"Only Routex provides native support for Plug and LiveView extensions","ref":"comparison.html#plug-liveview-integration"},{"type":"extras","title":"Dependencies - Routing solutions compared","doc":"Cldr Routes requires Cldr and Gettext. Although Routex core has no dependencies\non itself extensions may require additional dependencies. At this moment only\nthe Translations extension has a dependency: Gettext.","ref":"comparison.html#dependencies"},{"type":"extras","title":"Integration with other packages - Routing solutions compared","doc":"Unlike Cldr Routes, Routex is designed to seamlessly integrate with any\nthird-party package you choose. This flexibility allows you to combine Routex\nwith your existing package stack or custom solutions, tailoring its\nfunctionality to meet the specific needs of your application.","ref":"comparison.html#integration-with-other-packages"},{"type":"extras","title":"Developer Experience & Integration - Routing solutions compared","doc":"**Cldr Routes**  \nStreamlines localized route generation. However, its tight integration with the\nCldr suite and limited configuration options can limit flexibility and often\nnecessitates adjustments in templates and code. Requiring the use of a custom\nsigil `~q` for verified routers and `q` prefixed helper macros, it necessitates\nadjustments in existing templates and newly generated ones. The impact depends\non the size of the code base and the use of generators.\n\n```heex\n# Example in Cldr Routes:\n\n# Uses custom sigil ~q for localized routes\n<.link navigate=~q\"/products/#{product}\">My Link</.link>\n```\n\n\n**Routex**  \nIn contrast, Routex offers extensive configurability -such as customizable\nsigils and function names. It can be configured to shim the default Phoenix\nsigil `~p` and helper macros `url` and `path` or mimic Cldr Routes for Cldr\nintegration by using it's custom sigil and macros names. Meaning you can\nseamlessly incorporate Routex into your existing projects, preserving familiar\npatterns while enjoying cutting-edge features. Support for extensions with\nruntime features reduce manual wiring.\n\n```heex\n# Example in Routex:\n\n# Configurable to use standard Phoenix sigil ~p (as used in Phoenix' generators)\n<.link navigate=~p\"/products/#{product}\">My Link</.link>\n\n# or mimic Cldr Routes using sigil ~q\n<.link navigate=~q\"/products/#{product}\">My Link</.link>\n```\n\nThis flexibility is particularly useful when integrating with existing projects\nand code bases.","ref":"comparison.html#developer-experience-integration"},{"type":"extras","title":"Route processing - Routing solutions compared","doc":"Both projects generate routes during compile time. It's the way how they\ndo this and their runtime capabilities that makes the difference.\n\n**Cldr Routes**  \nCldr Routes takes your original route definition Abstract Syntaxt Tree (AST)\nwithin a localize block and transforms it into a new AST with localized paths.\nThere are no points for interception or extension points in this proces.\n\n```elixir\n localize do\n    get \"/pages/:page\", PageController, :show\n    resources \"/users\", UserController\n  end\n```\n\n\n**Routex**  \nRoutex intercepts your route definitions after they have been converted into\nstraightforward Route structs. It's extension processing system uses \"value\npassing\" so each extension in the pipeline receives the route structs including\nattributes and can modify or augment them before passing the updated routes on\nto the next extension. This approach makes it easier to trace and debug route\ntransformations at compile time.\n\nAt the end of the processing Routex passes the route structs to Phoenix Router\nfor native compilation.\n\nThis approach leverages the simpler and more predictable structure of Route\nstructs and route compilation by Phoenix Router itself, making the system more\nflexible, simpler to extend and easier to understand.\n\n```elixir\n# Routex supports the use of multiple configuration backends in one router. This means\n# that routes can have their own transformations, helper functions, or runtime features.\n\n# using configuration ExampleWeb.RoutexBackend\npreprocess_using ExampleWeb.RoutexBackend do\n   get \"/pages/:page\", PageController, :show\n   resources \"/users\", UserController\nend\n\n# using ExampleWeb.RoutexBackendAdmin\npreprocess_using ExampleWeb.RoutexBackendAdmin do\n   get \"/admin/:page\", PageController, :show\nend\n```","ref":"comparison.html#route-processing"},{"type":"extras","title":"Runtime capabilities - Routing solutions compared","doc":"**Cldr Routes**\nCldr Routes features only branching verified routes during runtime. It relies on\nexternal dependencies (like Cldr Plugs) to manage runtime locale detection,\nwhich necessitates adjustments in configuration and code for runtime\nlocalization.\n\n\n**Routex** Routex offers virtually unlimited runtime features and integration by\nintegrating native extension `Routex.Extension.RuntimeDispatcher` for dynamic\nfunctionality. This can be combined with other extensions -such as\n`Routex.Extension.Localize.Phoenix.Runtime` for highly customizable locale\ndetection and behavior during runtime.\n\n```elixir\ndefmodule ExampleWeb.RoutexBackend do\nuse Routex.Backend,  # makes this a Routex configuration backend\nextensions: [\n  Routex.Extension.Attrs,\n     Routex.Extension.Localize,  # detects locale, and puts it in runtime attributes\n     Routex.Extension.RuntimeDispatcher  # call arbitrary functions during runtime using route attributes\n],\n# configuration of arbitrary functions to be called at navigation events.\ndispatch_targets: [\n # Set Gettext locale from :language attribute\n {Gettext, :put_locale, [[:attrs, :language]]},\n # Call arbitrary function using other runtime attribute\n {MyApp, :my_function, [\"my value\", [:attrs, :runtime_attr_value], \"other value\"]}\n]\nend\n```\n\n\nRoutex supports extension-provided plugs and hooks that are generated at compile\ntime. By leveraging Elixir's powerful pattern matching, these plugs and hooks\nare optimized for performance, ensuring minimal runtime overhead even when\nmultiple runtime dispatch targets are enabled.​","ref":"comparison.html#runtime-capabilities"},{"type":"extras","title":"Conclusion - Routing solutions compared","doc":"In summary, both Cldr Routes and Routex significantly enhance Phoenix’s routing\ncapabilities, but they cater to different project needs. Cldr Routes offers a\nstreamlined, localized routing solution ideal for applications already using the\nCldr and Gettext ecosystems.\n\nOn the other hand, Routex stands out with its modular and extensible\narchitecture. It not only replicates the localization features of Cldr Routes\nbut also introduces advanced functionalities—such as customizable route\nattributes, runtime dispatching to external libs, and seamless integration with\nPlug and LiveView. This flexibility makes Routex a powerful choice for both new\nprojects and those looking to integrate dynamic routing features into an\nexisting codebase.\n\nUltimately, the decision between these libraries will depend on your project’s\nrequirements, existing dependencies, and desired level of customization. For\ndevelopers seeking a robust and adaptive routing framework, Routex offers\nextensive configurability and a richer feature set, while Cldr Routes remains a\ncompelling choice for straightforward localization needs.\n\n---\n\n \nThe `routex` -formerly known as `route_match`- as used by HandleCommerce\nis not related to the Routex as decribed in this document.","ref":"comparison.html#conclusion"},{"type":"extras","title":"Extensions","doc":"# Routex Extensions\n\n> #### List of extensions {: .info}\n> A [list of included extensions](README.md#extensions) can be found in the README.\n\nRoutex Extensions extend the functionality provided by Routex to transform\nroutes or generate new route based helper functions. Each extension is a module\nwhich implements the `Routex.Extension` behaviour.\n\nRoutex will call those callbacks at different stages before Routex handsoff the\nlist with routes to `Phoenix.Router` for compilation.\n\nEach extension provides a single feature and should minimize hard dependencies\non other extensions. Instead, Routex advises to make use of the `Routex.Attrs`\nsystem to share attributes; allowing extensions to work together without being\ncoupled.\n\nThe documentation of each extension lists any provided or required\n`Routex.Attrs`.","ref":"extension_development.html"},{"type":"extras","title":"Callbacks and stages - Extensions","doc":"","ref":"extension_development.html#callbacks-and-stages"},{"type":"extras","title":"Stage 1: Configure - Extensions","doc":"This stage enables extensions to preprocess backend options upfront.\n\nThe `configure/2` callback is called with the options provided to\n`Routex.Backend` and the name of the Routex backend. It is expected to return a\nnew list of options.\n\nRoutex collects all options in this stage for subsequent stages. Therefore,\nextensions should add any fallback/default they might use themselves to the\noptions in this stage.\n\nTo aid in code completion, the final configuration is passed as a struct to\nsubsequent stages.","ref":"extension_development.html#stage-1-configure"},{"type":"extras","title":"Stage 2: Transform - Extensions","doc":"This stage is meant to change the properties of routes, which are at that moment\n`Phoenix.Router.Route` structs. The routes are grouped by Routex backend and\nprocessed per group, allowing an extension to use accumulating values within one\niteration.\n\nThe `transform/3` callback is called with a list of routes belonging to a\nRoutex backend, the name of the backend and the current environment. It is\nexpected to return a list of Phoenix.Router.Route structs.\n\n\n#### Flattening option values\n\nExtensions can make use of `Routex.Attrs` provided by Routex itself, Routex\nbackends and other extensions.\n\nTo make the availability of the attributes as predictable as possible, Routex\nuses a flat structure which is stored in a routes' `private.routex` field.\nHowever, using a flat structure might conflict with developer experience;\nsometimes a nested structure to provide configuration options might be more\nsuitable.\n\nOne responsibility of the `transform/3` callback is to flatten the structure of\nattributes they use for each route they receive, so other extensions can use\nattributes set by the current extension without knowledge of the configuration\nstructure.\n\n**Example**\nThe Alternatives extension uses nested options and allows inheritance\nof attributes from parent branches.\n\n```\nalternatives: %{\n  \"/\" =>\n    helper: nil,\n    locale: \"en_GB\",\n    branches: %{\n      \"nl\" => %{\n          helper: \"nl\",\n          locale: \"nl_NL\"\n        },\n      \"gb\" => %{\n        helper: \"gb\",\n        }\n    }\n}\n```\nThe Alternatives module is therefor responsible for flattening those for\n(itself and) other extensions to use. To take the route responsible for the\n\"gb\" branch as an example, the extension should add flattened attributes in the\nRoute struct. It can do so using the helper function `Routex.Attrs.put/2`.\n\n```\nRoutex.Attrs.put(route, [locale: \"en_GB\", helper: \"gb\"])\n```\n\nNow the `Translation` extension can search for the option `:locale` in the\nroute's attributes, unaware of how that locale was initially configured.","ref":"extension_development.html#stage-2-transform"},{"type":"extras","title":"Stage 3: Post Transform - Extensions","doc":"The `post_transform` stage can be used knowing all other attributes of a route\nare available and no path will be transformed any further.","ref":"extension_development.html#stage-3-post-transform"},{"type":"extras","title":"Stage 4: Create helper functions - Extensions","doc":"In this stage helper functions can be generated which will be added to\n`MyAppWeb.Router.RoutexHelpers`.\n\nThe `create_helpers/3` callback is called with a list of routes belonging to a\nRoutex backend, the name of the Routex backend and the current environment.\nIt is expected to return Elixir AST.\n\nAs a result the developer only has to `import MyAppWeb.Router.RoutexHelpers`\nfor all helpers generated by extensions to be included in the app.","ref":"extension_development.html#stage-4-create-helper-functions"},{"type":"extras","title":"Guidelines - Extensions","doc":"* make functions not defined by the `Routex.Extension` behaviour private.\n* provide as many options and `Routex.Attrs` as possible; other extensions might use the information.\n* provide additional options and `Routex.Attrs` as flat list(s) so other extensions don't have to guess structure.\n* as other extensions might use options set by your extension, try to preserve any previously defined option or `Routex.Attrs` in future development","ref":"extension_development.html#guidelines"},{"type":"extras","title":"Important information about creating helpers - Extensions","doc":"Helpers are created by generating AST. The more AST has to be compiled, the more\ntime compilation takes.\n\n**Bad**\n```elixir\ndef foo(%Struct{foo: \"bar\"}), do: :bartender\ndef foo(%Struct{foo: \"zip\"}), do: :zippy\ndef foo(%Struct{foo: \"zelo\"}), do: :zarika\n(and then 1000 more)\n```\n\n**Good**\nLess AST is generated and the structs in only checked once.\n\n```elixir\ndef foo(%Struct{foo: my_var}), do: do_foo(my_var)\n\ndefp do_foo(\"bar\"), do: :bartender\ndefp do_foo(\"zip\"), do: :zippy\ndefp do_foo(\"zelo\"), do: :zarika\n(and then 1000 more)\nend\n```\n\nMore info: [thread about optimization at Elixir Forum](https://elixirforum.com/t/compiling-files-with-many-function-heads-is-very-slow-otp-26-issue/57105/25)","ref":"extension_development.html#important-information-about-creating-helpers"},{"type":"extras","title":"Documentation - Extensions","doc":"@moduledoc \"\"\"\n    Summary of feature provided.","ref":"extension_development.html#documentation"},{"type":"extras","title":"Options - Extensions","doc":"- `name` - description","ref":"extension_development.html#options"},{"type":"extras","title":"Example configuration - Extensions","doc":"```diff\n    # file lib/example_web/routex_backend.ex\n    defmodule ExampleWeb.RoutexBackend do\n      use Routex.Backend,\n      extensions: [\n    +   Routex.Extension.Name\n        Routex.Extension.Attrs\n    ],\n    + name_config: [name_opt: \"value\"]\n    ```","ref":"extension_development.html#example-configuration"},{"type":"extras","title":"Usage example - Extensions","doc":"```elixir\n    # file lib/example_web/template.ex\n    transform_template(\"/products/:id/edit\")\n    ```","ref":"extension_development.html#usage-example"},{"type":"extras","title":"Pseudo result - Extensions","doc":"```\n    /products/:id/edit  ⇒ /products/:id/edit\n    ```\n\n    ## `Routex.Attrs`\n    **Requires**\n    - none\n\n    **Sets**\n    - none","ref":"extension_development.html#pseudo-result"},{"type":"extras","title":"Helpers - Extensions","doc":"function_name(arg1 :: type) :: type\n    \"\"\"","ref":"extension_development.html#helpers"},{"type":"extras","title":"Contributing","doc":"# Contributing to Routex\n\nPlease take a moment to review this document in order to make the contribution\nprocess easy and effective for everyone involved!","ref":"contributing.html"},{"type":"extras","title":"Using the issue tracker - Contributing","doc":"Use the issues tracker for:\n\n* [Bug reports](#bug-reports)\n* [Submitting pull requests](#pull-requests)\n\nPlease **do not** use the issue tracker for personal support requests nor feature requests.\nFeature and support requests should be created on the Elixir forum and be tagged with at least `routex`\n\n* [Support Request](https://elixirforum.com/tag/routex)\n* [Feature Request](https://elixirforum.com/t/routex/69181)\n\nWe do our best to keep the issue tracker tidy and organized, making it useful\nfor everyone. For example, we classify open issues per perceived difficulty,\nmaking it easier for developers to [contribute to Routex](#pull-requests).","ref":"contributing.html#using-the-issue-tracker"},{"type":"extras","title":"Bug reports - Contributing","doc":"A bug is either a _demonstrable problem_ that is caused by the code in the repository,\nor indicate missing, unclear, or misleading documentation. Good bug reports are extremely\nhelpful - thank you!\n\nGuidelines for bug reports:\n\n1. **Use the GitHub issue search** &mdash; check if the issue has already been\n   reported.\n\n2. **Check if the issue has been fixed** &mdash; try to reproduce it using the\n   `master` branch in the repository.\n\n3. **Isolate and report the problem** &mdash; ideally create a reduced test\n   case.\n\nPlease try to be as detailed as possible in your report. Include information about\nyour Erlang, Elixir, Phoenix and Phoenix LiveView versions. Please provide steps to\nreproduce the issue as well as the outcome you were expecting! All these details\nwill help developers to fix any potential bugs.\n\nExample:\n\n> Short and descriptive example bug report title\n>\n> A summary of the issue and the environment in which it occurs. If suitable,\n> include the steps required to reproduce the bug.\n>\n> 1. This is the first step\n> 2. This is the second step\n> 3. Further steps, etc.\n>\n> ` ` - a link to the reduced test case (e.g. a GitHub Gist)\n>\n> Any other information you want to share that is relevant to the issue being\n> reported. This might include the lines of code that you have identified as\n> causing the bug, and potential solutions (and your opinions on their\n> merits).","ref":"contributing.html#bug-reports"},{"type":"extras","title":"Feature requests - Contributing","doc":"Feature requests are welcome and should be discussed on [the Routex topic on the Elixir forum](https://elixirforum.com/t/phoenix-localized-routes-localize-your-phoenix-website-with-multilingual-urls/48486). But take a moment to find\nout whether your idea fits with the scope and aims of the project. It's up to *you*\nto make a strong case to convince the community of the merits of this feature.\nPlease provide as much detail and context as possible.","ref":"contributing.html#feature-requests"},{"type":"extras","title":"Pull requests - Contributing","doc":"Good pull requests - patches, improvements, new features - are a fantastic\nhelp. They should remain focused in scope and avoid containing unrelated\ncommits.\n\n**IMPORTANT**: By submitting a patch, you agree that your work will be\nlicensed under the license used by the project.\n\nIf you have any large pull request in mind (e.g. implementing features,\nrefactoring code, etc), **please ask first** otherwise you risk spending\na lot of time working on something that the project's developers might\nnot want to merge into the project.\n\nPlease adhere to the coding conventions in the project (indentation,\naccurate comments, etc.) and don't forget to add your own tests and\ndocumentation. When working with git, we recommend the following process\nin order to craft an excellent pull request:\n\n1. [Fork](https://help.github.com/articles/fork-a-repo/) the project, clone your fork,\n   and configure the remotes:\n\n   ```bash\n   # Clone your fork of the repo into the current directory\n   git clone https://github.com/ /routex\n   # Navigate to the newly cloned directory\n   cd phoenix\n   # Assign the original repo to a remote called \"upstream\"\n   git remote add upstream https://github.com/BartOtten/routex\n   ```\n\n2. If you cloned a while ago, get the latest changes from upstream, and update your fork:\n\n   ```bash\n   git checkout master\n   git pull upstream master\n   git push\n   ```\n\n3. Create a new topic branch (off of `master`) to contain your feature, change,\n   or fix.\n\n   **IMPORTANT**: Making changes in `master` is discouraged. You should always\n   keep your local `master` in sync with upstream `master` and make your\n   changes in topic branches.\n\n   ```bash\n   git checkout -b  \n   ```\n\n4. Commit your changes in logical chunks. Keep your commit messages organized,\n   with a short description in the first line and more detailed information on\n   the following lines. Feel free to use Git's\n   [interactive rebase](https://help.github.com/articles/about-git-rebase/)\n   feature to tidy up your commits before making them public.\n\n5. Make sure all the tests are still passing.\n\n   ```bash\n   mix test\n   ```\n\n6. Push your topic branch up to your fork:\n\n   ```bash\n   git push origin  \n   ```\n\n7. [Open a Pull Request](https://help.github.com/articles/about-pull-requests/)\n    with a clear title and description.\n\n8. If you haven't updated your pull request for a while, you should consider\n   rebasing on master and resolving any conflicts.\n\n   **IMPORTANT**: _Never ever_ merge upstream `master` into your branches. You\n   should always `git rebase` on `master` to bring your changes up to date when\n   necessary.\n\n   ```bash\n   git checkout master\n   git pull upstream master\n   git checkout  \n   git rebase master\n   ```\n\nThank you for your contributions!","ref":"contributing.html#pull-requests"},{"type":"extras","title":"Guides - Contributing","doc":"These Guides aim to be inclusive. We use \"we\" and \"our\" instead of \"you\" and\n\"your\" to foster this sense of inclusion.\n\nIdeally there is something for everybody in each guide, from beginner to expert.\nThis is hard, maybe impossible. When we need to compromise, we do so on behalf\nof beginning users because expert users have more tools at their disposal to\nhelp themselves.\n\nThe general pattern we use for presenting information is to first introduce a\nsmall, discrete topic, then write a small amount of code to demonstrate the\nconcept, then verify that the code worked.\n\nIn this way, we build from small, easily digestible concepts into more complex\nones. The shorter this cycle is, as long as the information is still clear and\ncomplete, the better.\n\nFor formatting the guides:\n\n- We use the \"elixir\" code fence for all module code.\n- We use the \"console\" code fence for iex and shell commands.\n- We use the \"html\" code fence for html templates, even if there is elixir code\n  in the template.\n- We use backticks for filenames and directory paths.\n- We use backticks for module names, function names, and variable names.","ref":"contributing.html#guides"},{"type":"extras","title":"Troubleshooting","doc":"# Troubleshooting","ref":"troubleshooting.html"},{"type":"extras","title":"Where can I find ExampleWeb.Router.RoutexHelpers? - Troubleshooting","doc":"This module does not have a code file. It is generated during compile time\nby Routex. You should be able to see a message in the output like the one below:\n\n    Completed: ExampleWeb.RoutexCldrBackend ⇒ Routex.Extension.VerifiedRoutes.create_helpers/3\n    Create or update helper module ExampleWeb.Router.RoutexHelpers\n\nOnce your project is compiled, you can access it in `iex`.\n\n    iex> exports ExampleWeb.Router.RoutexHelper\n    alternatives/1                     attrs/1                            on_mount/4\n    sigil_o/2                          sigil_p/2                          url/1\n    url/2                              url/3                              url_phx/1\n\n    iex> h ExampleWeb.Router.RoutexHelper.attrs\n\n              def attrs(url)\n    Returns Routex attributes of given URL","ref":"troubleshooting.html#where-can-i-find-exampleweb-router-routexhelpers"},{"type":"extras","title":"Compilation - Troubleshooting","doc":"If you run into compilation issues try these solutions first. If they\ndo not solve the issue or the issue re-appears, fell free to open an issue.","ref":"troubleshooting.html#compilation"},{"type":"extras","title":"Clearing your _build folder - Troubleshooting","doc":"Clearing your build folder might fix issues; especially when the\norder of module compilation is the suspect.\n\n`rm -Rf _build && mix compile`","ref":"troubleshooting.html#clearing-your-_build-folder"},{"type":"extras","title":"Debugging - Troubleshooting","doc":"When your application fails to compile you might find the cause by setting the\nenvironment variable `ROUTEX_DEBUG` to `true`.\n\n    ROUTEX_DEBUG=true mix compile\n\nDo note that this might show early compilation issues, but will make the final\ncompilation fail at all times.","ref":"troubleshooting.html#debugging"}],"proglang":"elixir","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.39.1"}}